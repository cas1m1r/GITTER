{
  "logs": [
    "/home/cas1m1r/GITTER/Users/NEKITOS911/nekitos911.git.Multicollisions"
  ],
  "username": "nekitos911",
  "repos": {
    "Multicollisions": {
      "commits": [
        "3a4cefed3579a8140d52b6564caf6519b837f5ec",
        "119f84b3383e2dbcc756c84cb2f7ca7bc8a49ae1",
        "fb82f865aafc3e9abdc34ff516685017db8c4427",
        "77e3215aab5fe78d74c26d2f4d37d5ea93f1a1ff",
        "7650f7d5f923c36d54b2c70e39361386e73599dd",
        "d493e1913ede701e8c135e0e1a601ec45be6f0ea",
        "58e22bf6d1240f4da35626972d57dbc0aefcd48c",
        "b8fc964f3e81efb9009b696066ee4c8592e19ce6",
        "7779f2ac6180f22e02ef1c0d99bb188b3a8fa768",
        "61a6cd9c2e197f751acbca8f204c552af61eed8c",
        "15448f3b65b466d4522396d151c439fe613300bc",
        "f32f8da5753c0e153bca25b14b516e1af8da4c26",
        ""
      ],
      "files": [
        "SANDBOX/Multicollisions",
        "\u251c\u2500\u2500 Images",
        "\u2502\u00a0\u00a0 \u2514\u2500\u2500 empty_img.txt",
        "\u251c\u2500\u2500 Presentation",
        "\u2502\u00a0\u00a0 \u2514\u2500\u2500 empty_presentation.txt",
        "\u2514\u2500\u2500 Solution",
        "    \u251c\u2500\u2500 Algorithm",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Algorithm.csproj",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 App.config",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 FodyWeavers.xml",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 MagicInput.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 MultiCollisions.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Options.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Program.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Properties",
        "    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 AssemblyInfo.cs",
        "    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Utils.cs",
        "    \u251c\u2500\u2500 Algorithm.Tests",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Algorithm.Tests.csproj",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 packages.config",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Properties",
        "    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 AssemblyInfo.cs",
        "    \u2502\u00a0\u00a0 \u2514\u2500\u2500 TestMultiCollisions.cs",
        "    \u251c\u2500\u2500 MoraHash",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 ByteUtils.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Constants.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 HashFunction.cs",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 MoraHash.csproj",
        "    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Properties",
        "    \u2502\u00a0\u00a0     \u2514\u2500\u2500 AssemblyInfo.cs",
        "    \u251c\u2500\u2500 MoraHash.Tests",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 MoraHash.Tests.csproj",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 packages.config",
        "    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Properties",
        "    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 AssemblyInfo.cs",
        "    \u2502\u00a0\u00a0 \u2514\u2500\u2500 TestMoraHash.cs",
        "    \u2514\u2500\u2500 Multicollisions.sln",
        "",
        "11 directories, 25 files",
        ""
      ],
      "branches": [
        "* master",
        ""
      ],
      "changes": {
        "3a4cefed3579a8140d52b6564caf6519b837f5ec": [
          "commit 3a4cefed3579a8140d52b6564caf6519b837f5ec",
          "Author: nekitos911 <n.i.k.tver@yandex.ru>",
          "Date:   Thu Jan 14 00:06:00 2021 +0300",
          "",
          "    Delete empty_diploma.txt",
          "",
          "diff --git a/Text/empty_diploma.txt b/Text/empty_diploma.txt",
          "deleted file mode 100644",
          "index e69de29..0000000",
          ""
        ],
        "119f84b3383e2dbcc756c84cb2f7ca7bc8a49ae1": [
          "commit 119f84b3383e2dbcc756c84cb2f7ca7bc8a49ae1",
          "Author: nekitos911 <n.i.k.tver@yandex.ru>",
          "Date:   Thu Jan 14 00:05:53 2021 +0300",
          "",
          "    Delete Multicollisions in Hash Function Mora.docx",
          "",
          "diff --git a/Text/Multicollisions in Hash Function Mora.docx b/Text/Multicollisions in Hash Function Mora.docx",
          "deleted file mode 100644",
          "index f125014..0000000",
          "Binary files a/Text/Multicollisions in Hash Function Mora.docx and /dev/null differ",
          ""
        ],
        "fb82f865aafc3e9abdc34ff516685017db8c4427": [
          "commit fb82f865aafc3e9abdc34ff516685017db8c4427",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Wed Dec 30 19:05:17 2020 +0300",
          "",
          "    stolen files",
          "",
          "diff --git a/Solution/Algorithm/Properties/AssemblyInfo.cs b/Solution/Algorithm/Properties/AssemblyInfo.cs",
          "new file mode 100644",
          "index 0000000..987aab9",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/Properties/AssemblyInfo.cs",
          "@@ -0,0 +1,35 @@",
          "+\ufeffusing System.Reflection;",
          "+using System.Runtime.InteropServices;",
          "+",
          "+// General Information about an assembly is controlled through the following ",
          "+// set of attributes. Change these attribute values to modify the information",
          "+// associated with an assembly.",
          "+[assembly: AssemblyTitle(\"Algorithm\")]",
          "+[assembly: AssemblyDescription(\"\")]",
          "+[assembly: AssemblyConfiguration(\"\")]",
          "+[assembly: AssemblyCompany(\"\")]",
          "+[assembly: AssemblyProduct(\"Algorithm\")]",
          "+[assembly: AssemblyCopyright(\"Copyright \u00a9  2020\")]",
          "+[assembly: AssemblyTrademark(\"\")]",
          "+[assembly: AssemblyCulture(\"\")]",
          "+",
          "+// Setting ComVisible to false makes the types in this assembly not visible ",
          "+// to COM components.  If you need to access a type in this assembly from ",
          "+// COM, set the ComVisible attribute to true on that type.",
          "+[assembly: ComVisible(false)]",
          "+",
          "+// The following GUID is for the ID of the typelib if this project is exposed to COM",
          "+[assembly: Guid(\"98508736-247B-41BB-9221-70C900431B19\")]",
          "+",
          "+// Version information for an assembly consists of the following four values:",
          "+//",
          "+//      Major Version",
          "+//      Minor Version ",
          "+//      Build Number",
          "+//      Revision",
          "+//",
          "+// You can specify all the values or you can default the Build and Revision Numbers ",
          "+// by using the '*' as shown below:",
          "+// [assembly: AssemblyVersion(\"1.0.*\")]",
          "+[assembly: AssemblyVersion(\"1.0.0.0\")]",
          "+[assembly: AssemblyFileVersion(\"1.0.0.0\")]",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash/Properties/AssemblyInfo.cs b/Solution/MoraHash/Properties/AssemblyInfo.cs",
          "new file mode 100644",
          "index 0000000..a9935fb",
          "--- /dev/null",
          "+++ b/Solution/MoraHash/Properties/AssemblyInfo.cs",
          "@@ -0,0 +1,35 @@",
          "+\ufeffusing System.Reflection;",
          "+using System.Runtime.InteropServices;",
          "+",
          "+// General Information about an assembly is controlled through the following ",
          "+// set of attributes. Change these attribute values to modify the information",
          "+// associated with an assembly.",
          "+[assembly: AssemblyTitle(\"ClassLibrary1\")]",
          "+[assembly: AssemblyDescription(\"\")]",
          "+[assembly: AssemblyConfiguration(\"\")]",
          "+[assembly: AssemblyCompany(\"\")]",
          "+[assembly: AssemblyProduct(\"ClassLibrary1\")]",
          "+[assembly: AssemblyCopyright(\"Copyright \u00a9  2020\")]",
          "+[assembly: AssemblyTrademark(\"\")]",
          "+[assembly: AssemblyCulture(\"\")]",
          "+",
          "+// Setting ComVisible to false makes the types in this assembly not visible ",
          "+// to COM components.  If you need to access a type in this assembly from ",
          "+// COM, set the ComVisible attribute to true on that type.",
          "+[assembly: ComVisible(false)]",
          "+",
          "+// The following GUID is for the ID of the typelib if this project is exposed to COM",
          "+[assembly: Guid(\"8A69AA3F-5FEA-451B-9EFE-528B68BC478C\")]",
          "+",
          "+// Version information for an assembly consists of the following four values:",
          "+//",
          "+//      Major Version",
          "+//      Minor Version ",
          "+//      Build Number",
          "+//      Revision",
          "+//",
          "+// You can specify all the values or you can default the Build and Revision Numbers ",
          "+// by using the '*' as shown below:",
          "+// [assembly: AssemblyVersion(\"1.0.*\")]",
          "+[assembly: AssemblyVersion(\"1.0.0.0\")]",
          "+[assembly: AssemblyFileVersion(\"1.0.0.0\")]",
          "\\ No newline at end of file",
          "diff --git a/Text/Multicollisions in Hash Function Mora.docx b/Text/Multicollisions in Hash Function Mora.docx",
          "new file mode 100644",
          "index 0000000..f125014",
          "Binary files /dev/null and b/Text/Multicollisions in Hash Function Mora.docx differ",
          ""
        ],
        "77e3215aab5fe78d74c26d2f4d37d5ea93f1a1ff": [
          "commit 77e3215aab5fe78d74c26d2f4d37d5ea93f1a1ff",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Wed Dec 30 19:03:43 2020 +0300",
          "",
          "    multicollisions test",
          "",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "index 09d8d43..39809c6 100644",
          "--- a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "@@ -10,13 +10,24 @@",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "         <e p=\"FodyWeavers.xml\" t=\"Include\" />",
          "         <e p=\"MagicInput.cs\" t=\"Include\" />",
          "-        <e p=\"Multicollision.cs\" t=\"Include\" />",
          "+        <e p=\"MultiCollisions.cs\" t=\"Include\" />",
          "         <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "         <e p=\"Options.cs\" t=\"Include\" />",
          "         <e p=\"Program.cs\" t=\"Include\" />",
          "         <e p=\"Properties\" t=\"Include\">",
          "           <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "         </e>",
          "+        <e p=\"Utils.cs\" t=\"Include\" />",
          "+      </e>",
          "+      <e p=\"Algorithm.Tests\" t=\"IncludeRecursive\">",
          "+        <e p=\"Algorithm.Tests.csproj\" t=\"IncludeRecursive\" />",
          "+        <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"packages.config\" t=\"Include\" />",
          "+        <e p=\"Properties\" t=\"Include\">",
          "+          <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "+        </e>",
          "+        <e p=\"TestMultiCollisions.cs\" t=\"Include\" />",
          "       </e>",
          "       <e p=\"MoraHash\" t=\"IncludeRecursive\">",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "diff --git a/Solution/Algorithm.Tests/Algorithm.Tests.csproj b/Solution/Algorithm.Tests/Algorithm.Tests.csproj",
          "new file mode 100644",
          "index 0000000..7a19bcf",
          "--- /dev/null",
          "+++ b/Solution/Algorithm.Tests/Algorithm.Tests.csproj",
          "@@ -0,0 +1,76 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",
          "+  <Import Project=\"..\\packages\\NUnit.3.12.0\\build\\NUnit.props\" Condition=\"Exists('..\\packages\\NUnit.3.12.0\\build\\NUnit.props')\" />",
          "+  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />",
          "+  <PropertyGroup>",
          "+    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>",
          "+    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>",
          "+    <ProjectGuid>{061ED14B-8389-4CE0-9D3B-373D8FABCA50}</ProjectGuid>",
          "+    <OutputType>Library</OutputType>",
          "+    <AppDesignerFolder>Properties</AppDesignerFolder>",
          "+    <RootNamespace>Algorithm.Tests</RootNamespace>",
          "+    <AssemblyName>Algorithm.Tests</AssemblyName>",
          "+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>",
          "+    <FileAlignment>512</FileAlignment>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugSymbols>true</DebugSymbols>",
          "+    <DebugType>full</DebugType>",
          "+    <Optimize>false</Optimize>",
          "+    <OutputPath>bin\\Debug\\</OutputPath>",
          "+    <DefineConstants>DEBUG;TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugType>pdbonly</DebugType>",
          "+    <Optimize>true</Optimize>",
          "+    <OutputPath>bin\\Release\\</OutputPath>",
          "+    <DefineConstants>TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <ItemGroup>",
          "+    <Reference Include=\"nunit.framework, Version=3.12.0.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\">",
          "+      <HintPath>..\\packages\\NUnit.3.12.0\\lib\\net45\\nunit.framework.dll</HintPath>",
          "+      <Private>True</Private>",
          "+    </Reference>",
          "+    <Reference Include=\"System\" />",
          "+    <Reference Include=\"System.Core\" />",
          "+    <Reference Include=\"System.Data\" />",
          "+    <Reference Include=\"System.Xml\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <Compile Include=\"TestMultiCollisions.cs\" />",
          "+    <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <None Include=\"packages.config\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <ProjectReference Include=\"..\\Algorithm\\Algorithm.csproj\">",
          "+      <Project>{98508736-247b-41bb-9221-70c900431b19}</Project>",
          "+      <Name>Algorithm</Name>",
          "+    </ProjectReference>",
          "+    <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\">",
          "+      <Project>{8a69aa3f-5fea-451b-9efe-528b68bc478c}</Project>",
          "+      <Name>MoraHash</Name>",
          "+    </ProjectReference>",
          "+  </ItemGroup>",
          "+  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />",
          "+  <Target Name=\"EnsureNuGetPackageBuildImports\" BeforeTargets=\"PrepareForBuild\">",
          "+    <PropertyGroup>",
          "+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105.The missing file is {0}.</ErrorText>",
          "+    </PropertyGroup>",
          "+    <Error Condition=\"!Exists('..\\packages\\NUnit.3.12.0\\build\\NUnit.props')\" Text=\"$([System.String]::Format('$(ErrorText)', '..\\packages\\NUnit.3.12.0\\build\\NUnit.props'))\" />",
          "+  </Target>",
          "+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ",
          "+         Other similar extension points exist, see Microsoft.Common.targets.",
          "+    <Target Name=\"BeforeBuild\">",
          "+    </Target>",
          "+    <Target Name=\"AfterBuild\">",
          "+    </Target>",
          "+    -->",
          "+</Project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm.Tests/Properties/AssemblyInfo.cs b/Solution/Algorithm.Tests/Properties/AssemblyInfo.cs",
          "new file mode 100644",
          "index 0000000..e9cb46a",
          "--- /dev/null",
          "+++ b/Solution/Algorithm.Tests/Properties/AssemblyInfo.cs",
          "@@ -0,0 +1,35 @@",
          "+\ufeffusing System.Reflection;",
          "+using System.Runtime.InteropServices;",
          "+",
          "+// General Information about an assembly is controlled through the following ",
          "+// set of attributes. Change these attribute values to modify the information",
          "+// associated with an assembly.",
          "+[assembly: AssemblyTitle(\"Algorithm.Tests\")]",
          "+[assembly: AssemblyDescription(\"\")]",
          "+[assembly: AssemblyConfiguration(\"\")]",
          "+[assembly: AssemblyCompany(\"\")]",
          "+[assembly: AssemblyProduct(\"Algorithm.Tests\")]",
          "+[assembly: AssemblyCopyright(\"Copyright \u00a9  2020\")]",
          "+[assembly: AssemblyTrademark(\"\")]",
          "+[assembly: AssemblyCulture(\"\")]",
          "+",
          "+// Setting ComVisible to false makes the types in this assembly not visible ",
          "+// to COM components.  If you need to access a type in this assembly from ",
          "+// COM, set the ComVisible attribute to true on that type.",
          "+[assembly: ComVisible(false)]",
          "+",
          "+// The following GUID is for the ID of the typelib if this project is exposed to COM",
          "+[assembly: Guid(\"061ED14B-8389-4CE0-9D3B-373D8FABCA50\")]",
          "+",
          "+// Version information for an assembly consists of the following four values:",
          "+//",
          "+//      Major Version",
          "+//      Minor Version ",
          "+//      Build Number",
          "+//      Revision",
          "+//",
          "+// You can specify all the values or you can default the Build and Revision Numbers ",
          "+// by using the '*' as shown below:",
          "+// [assembly: AssemblyVersion(\"1.0.*\")]",
          "+[assembly: AssemblyVersion(\"1.0.0.0\")]",
          "+[assembly: AssemblyFileVersion(\"1.0.0.0\")]",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm.Tests/TestMultiCollisions.cs b/Solution/Algorithm.Tests/TestMultiCollisions.cs",
          "new file mode 100644",
          "index 0000000..3c9ffcb",
          "--- /dev/null",
          "+++ b/Solution/Algorithm.Tests/TestMultiCollisions.cs",
          "@@ -0,0 +1,78 @@",
          "+\ufeffusing System;",
          "+using System.Collections;",
          "+using System.Collections.Generic;",
          "+using System.Linq;",
          "+using MoraHash;",
          "+using NUnit.Framework;",
          "+",
          "+namespace Algorithm.Tests",
          "+{",
          "+    public class TestMultiCollisions",
          "+    {",
          "+",
          "+        private class ByteArrayComparer : IEqualityComparer<byte[]>",
          "+        {",
          "+            private static ByteArrayComparer _default;",
          "+",
          "+            public static ByteArrayComparer Default => _default ?? (_default = new ByteArrayComparer());",
          "+",
          "+            public bool Equals(byte[] x, byte[] y)",
          "+            {",
          "+                return StructuralComparisons.StructuralEqualityComparer.Equals(x, y);",
          "+            }",
          "+",
          "+            public int GetHashCode(byte[] obj)",
          "+            {",
          "+                return StructuralComparisons.StructuralEqualityComparer.GetHashCode(obj);",
          "+            }",
          "+        }",
          "+",
          "+        [Test]",
          "+        public void TestCollisions()",
          "+        {",
          "+            var mora = new HashFunction();",
          "+",
          "+            var lst = new List<List<ulong>>();",
          "+            var solutions = new List<ulong[]>();",
          "+            ",
          "+            // \u041a\u043e\u043b\u043b\u0438\u0437\u0438\u0438 \u043d\u0430\u0439\u0434\u0435\u043d\u044b \u0437\u0430\u0440\u0430\u043d\u0435\u0435",
          "+            // 15191912733080746243 : 2816499036862610626",
          "+            // 12602365574662108235 : 15317591334086282728",
          "+//            2541090681042594495 : 12112829685509080139",
          "+//            8325695980190155696 : 10246617843613846309",
          "+//            4364755641628337682 : 7731428877087533129",
          "+            lst.Add(new List<ulong>() {4364755641628337682, 7731428877087533129});",
          "+            lst.Add(new List<ulong>() {8325695980190155696, 10246617843613846309});",
          "+            lst.Add(new List<ulong>() {2541090681042594495, 12112829685509080139});",
          "+            lst.Add(new List<ulong>() {12602365574662108235, 15317591334086282728});",
          "+            lst.Add(new List<ulong>() {15191912733080746243, 2816499036862610626});",
          "+            ",
          "+            Utils.Solve(lst, solutions, new ulong[lst.Count]);",
          "+",
          "+            var messages = solutions.Select(seq =>",
          "+            {",
          "+                IEnumerable<byte> ret = new byte[0];",
          "+",
          "+                ret = seq.Aggregate(ret, (current, value) => ",
          "+                    current.Concat(BitConverter.GetBytes(ulong.MaxValue - value + 1).Reverse())",
          "+                    .Concat(BitConverter.GetBytes(value).Reverse()));",
          "+",
          "+                return ret.ToArray();",
          "+            }).ToArray();",
          "+            ",
          "+            Assert.True(solutions.Count() == 1 << lst.Count());",
          "+            ",
          "+            bool allMessagesAreDifferent = messages.Distinct(ByteArrayComparer.Default).Count() == messages.Length;",
          "+            ",
          "+            Assert.True(allMessagesAreDifferent);",
          "+            ",
          "+            // 2 ^ lst.Count \u0445\u0435\u0448\u0438",
          "+            var hashes = messages.Select(msg => mora.ComputeHash(msg)).ToArray();",
          "+",
          "+            // \u0412\u0441\u0435 \u0445\u0435\u0448\u0438 \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u043c\u0435\u0442\u044c \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435",
          "+            bool allHashesAreEqual = hashes.All(hash => hash.SequenceEqual(hashes.First()));",
          "+            ",
          "+            Assert.True(allHashesAreEqual);",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm.Tests/packages.config b/Solution/Algorithm.Tests/packages.config",
          "new file mode 100644",
          "index 0000000..4157381",
          "--- /dev/null",
          "+++ b/Solution/Algorithm.Tests/packages.config",
          "@@ -0,0 +1,4 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<packages>",
          "+  <package id=\"NUnit\" version=\"3.12.0\" targetFramework=\"net472\" />",
          "+</packages>",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Algorithm.csproj b/Solution/Algorithm/Algorithm.csproj",
          "index 1101677..b3fb0f0 100644",
          "--- a/Solution/Algorithm/Algorithm.csproj",
          "+++ b/Solution/Algorithm/Algorithm.csproj",
          "@@ -43,10 +43,11 @@",
          "   </ItemGroup>",
          "   <ItemGroup>",
          "     <Compile Include=\"MagicInput.cs\" />",
          "-    <Compile Include=\"Multicollision.cs\" />",
          "+    <Compile Include=\"MultiCollisions.cs\" />",
          "     <Compile Include=\"Options.cs\" />",
          "     <Compile Include=\"Program.cs\" />",
          "     <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "+    <Compile Include=\"Utils.cs\" />",
          "   </ItemGroup>",
          "   <ItemGroup>",
          "     <Content Include=\"FodyWeavers.xml\" />",
          "diff --git a/Solution/Algorithm/MultiCollisions.cs b/Solution/Algorithm/MultiCollisions.cs",
          "new file mode 100644",
          "index 0000000..16d2ca1",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/MultiCollisions.cs",
          "@@ -0,0 +1,463 @@",
          "+\ufeffusing System;",
          "+using System.Collections.Concurrent;",
          "+using System.Collections.Generic;",
          "+using System.Diagnostics;",
          "+using System.Linq;",
          "+using System.Security.Cryptography;",
          "+using System.Threading.Tasks;",
          "+using Alea;",
          "+using Alea.CSharp;",
          "+using Alea.Parallel;",
          "+using MoraHash;",
          "+using ServiceStack;",
          "+",
          "+namespace Algorithm",
          "+{",
          "+    public class MultiCollisions",
          "+    {",
          "+        private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();",
          "+        ",
          "+        private static readonly GlobalArraySymbol<ulong> ConstC = Gpu.DefineConstantArraySymbol<ulong>(Constants.C.Length);",
          "+        private static readonly GlobalArraySymbol<int> ConstSbox = Gpu.DefineConstantArraySymbol<int>(Constants.SBox.Length);",
          "+        private static readonly GlobalArraySymbol<int> ConstTau = Gpu.DefineConstantArraySymbol<int>(Constants.Tau.Length);",
          "+        private static readonly GlobalArraySymbol<int> ConstL = Gpu.DefineConstantArraySymbol<int>(Constants.L.Length);",
          "+",
          "+        private async Task<ulong> AsyncG_n(ulong N, ulong h, ulong m)",
          "+        {",
          "+            return await Task.Run(() => G_n(N, h, m));",
          "+        }",
          "+        ",
          "+        private MagicInput GetMagic(MagicInput input, ulong n, ulong h, int size)",
          "+        {",
          "+            var x = input.X0;",
          "+            var x0 = input.X0;",
          "+            var counter = 0;",
          "+            //if first 32 - size bits are zero, x - magic num",
          "+            while (x >> (32 + size) != 0)",
          "+            {",
          "+                x = Function(n, h, x);",
          "+                counter++;",
          "+            }",
          "+",
          "+            return new MagicInput() {X = x, X0 = x0, Counter = counter};",
          "+        }",
          "+        ",
          "+        private MagicInput GetMagicGPU(MagicInput input, ulong n, ulong h, int size)",
          "+        {",
          "+            var x = input.X0;",
          "+            var x0 = input.X0;",
          "+            var counter = 0;",
          "+            //if first 32 - size bits are zero, x - magic num",
          "+            while (x >> (32 + size) != 0)",
          "+            {",
          "+                x = FunctionGPU(n, h, x);",
          "+                counter++;",
          "+            }",
          "+",
          "+            return new MagicInput() {X = x, X0 = x0, Counter = counter};",
          "+        }",
          "+",
          "+        private MagicInput[] MagicCycle(MagicInput[] input, int maxSize, ulong n, ulong h)",
          "+        {",
          "+            var t = (int)Math.Log(maxSize, 2);",
          "+            var result = new MagicInput[input.Length];",
          "+",
          "+            Parallel.For(0, result.Length, (i) =>",
          "+            {",
          "+                result[i] = GetMagic(input[i], n, h, t);",
          "+            });",
          "+            return result;",
          "+        }",
          "+",
          "+        [GpuManaged]",
          "+        private MagicInput[] MagicCycleGPU(MagicInput[] input, int maxSize, ulong n, ulong h)",
          "+        {",
          "+            var t = (int)Math.Log(maxSize, 2);",
          "+            var result = new MagicInput[input.Length];",
          "+             ",
          "+            Gpu.Default.For(0, result.Length, i =>",
          "+            {",
          "+                result[i] = GetMagicGPU(input[i], n, h, t);",
          "+            });",
          "+            ",
          "+            return result;",
          "+        }",
          "+",
          "+        private (ulong, ulong) MagicPoints(ulong n, ulong h)",
          "+        {",
          "+            (ulong, ulong) retVal = (0, 0);",
          "+            var dict = new ConcurrentDictionary<ulong, (ulong, long)>();",
          "+            var maxSize = 1_050_000;",
          "+            var step = 10_000;",
          "+",
          "+            while (true)",
          "+            {",
          "+                Console.WriteLine(\"Begin\");",
          "+                var input = new ulong[maxSize].AsParallel().Select(data => BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0)).Select(data => new MagicInput() {X0 = data}).ToArray();",
          "+                for (int i = 0; i < maxSize; i+= step)",
          "+                {",
          "+                    var st = new Stopwatch();",
          "+                    st.Start();",
          "+                    var result = MagicCycleGPU(input.Skip(i).Take(step).ToArray(), maxSize, n, h);",
          "+                    st.Stop();",
          "+                    var time = st.ElapsedMilliseconds;",
          "+                    Console.WriteLine(time);",
          "+                    ",
          "+                    Parallel.ForEach(result, (res, state) =>",
          "+                    {",
          "+                        var x = res.X;",
          "+                        var x0 = res.X0;",
          "+                        var count = res.Counter;",
          "+",
          "+                        if (!dict.ContainsKey(x))",
          "+                        {",
          "+                            dict[x] = (x0, count);",
          "+                        }",
          "+                        else",
          "+                        {",
          "+                            var x1 = dict[x].Item1;",
          "+                            var count1 = dict[x].Item2;",
          "+                        ",
          "+                            while (count1 > count)",
          "+                            {",
          "+                                x1 = Function(n, h, x1);",
          "+                                count1--;",
          "+                            }",
          "+",
          "+                            while (count > count1)",
          "+                            {",
          "+                                x0 = Function(n, h, x0);",
          "+                                count--;",
          "+                            }",
          "+",
          "+                            while (true)",
          "+                            {",
          "+                                var next = Function(n, h, x1);",
          "+                                var next2 = Function(n, h, x0);",
          "+",
          "+                                if (next == next2) break;",
          "+",
          "+                                x1 = next;",
          "+                                x0 = next2;",
          "+                            }",
          "+",
          "+                            if (x1 != 0 && x0 != 0)",
          "+                            {",
          "+                                retVal.Item1 = x1;",
          "+                                retVal.Item2 = x0;",
          "+                                state.Break();",
          "+                            }",
          "+                        }",
          "+                    });",
          "+",
          "+                    if (retVal != (0, 0)) break;",
          "+                }",
          "+                if (retVal != (0, 0)) break;",
          "+            }",
          "+            ",
          "+            return retVal;",
          "+        }",
          "+        ",
          "+        private (ulong, ulong) Brent(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var power = 1;",
          "+            var lam = 1;",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0));",
          "+  ",
          "+            var tortoise = x0;",
          "+            var hare = G_n(0, 0, x0);",
          "+",
          "+            while (tortoise != hare)",
          "+            {",
          "+                if (power == lam)",
          "+                {",
          "+                    tortoise = hare;",
          "+                    power *= 2;",
          "+                    lam = 0;",
          "+                }",
          "+                hare = G_n(0, 0, hare);",
          "+                lam++;",
          "+            }",
          "+            ",
          "+            tortoise = hare = x0;",
          "+",
          "+            for (int i = 0; i < lam; i++)",
          "+            {",
          "+                hare = G_n(0, 0, hare);",
          "+            }",
          "+",
          "+            while (true)",
          "+            {",
          "+                var nextTask = AsyncG_n(0, 0, tortoise);",
          "+                var next2Task = AsyncG_n(0, 0, hare);",
          "+                            ",
          "+                Task.WaitAll(nextTask, next2Task);",
          "+                            ",
          "+                if (nextTask.Result == next2Task.Result) break;",
          "+            ",
          "+                tortoise = nextTask.Result;",
          "+                hare = next2Task.Result;",
          "+            }",
          "+",
          "+            return (tortoise, hare);",
          "+        }",
          "+        ",
          "+        private (ulong, ulong) Floyd(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0));",
          "+",
          "+            var hare = x0;",
          "+            var tortoise = x0;",
          "+",
          "+            while (true)",
          "+            {",
          "+                hare = G_n(0, 0, G_n(0, 0, hare));",
          "+                tortoise = G_n(0, 0, tortoise);",
          "+                ",
          "+                if (hare == tortoise)",
          "+                {",
          "+                    break;",
          "+                }",
          "+            }",
          "+",
          "+            tortoise = x0;",
          "+",
          "+            while (true)",
          "+            {",
          "+                var nextTask = G_n(0, 0, tortoise);",
          "+                var next2Task = G_n(0, 0, hare);",
          "+",
          "+                if (nextTask == next2Task) break;",
          "+            }",
          "+",
          "+            return (tortoise, hare);",
          "+        }",
          "+",
          "+        private static int SplitLeftByte(ulong data, int byteNum)",
          "+        {",
          "+            int shift = (8 * byteNum);",
          "+            var b = (data >> shift) & 0xff;",
          "+            return (int)(b >> 4);",
          "+        }",
          "+        ",
          "+        private static int SplitRightByte(ulong data, int byteNum)",
          "+        {",
          "+            int shift = (8 * byteNum);",
          "+            var b = (data >> shift) & 0xff;",
          "+            return (int)(b & 0xf);",
          "+        }",
          "+        ",
          "+        private static ulong JoinBytes(int hi, int low)",
          "+        {",
          "+            return (ulong)((hi << 4) | (low & 0xffffffffL));",
          "+        }",
          "+",
          "+        #region G_n",
          "+",
          "+        public static ulong P(ulong state)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (64 - 8 - 8 * i);",
          "+                var l = Constants.Tau[i * 2] % 2 == 0 ? SplitLeftByte(state, 7 - Constants.Tau[i * 2] / 2) : SplitRightByte(state, 7 - Constants.Tau[i * 2] / 2);",
          "+                var r = Constants.Tau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, 7 - Constants.Tau[i * 2 + 1] / 2) : SplitRightByte(state, 7 - Constants.Tau[i * 2 + 1] / 2);",
          "+                ret |= JoinBytes(l, r) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        public static ulong S(ulong state)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (8 * i);",
          "+                ret |= JoinBytes(Constants.SBox[SplitLeftByte(state, i)], Constants.SBox[SplitRightByte(state, i)]) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        public static ulong L(ulong state)",
          "+        {",
          "+            ulong result = 0;",
          "+",
          "+            for (int i = 0; i < 4; i++)",
          "+            {",
          "+                int t = 0;",
          "+                for(int k = 0; k < 16; k++) {",
          "+                    if ((state & (1UL << (k + i * 16))) != 0)",
          "+                    {",
          "+                        t ^= Constants.L[16 - k - 1];",
          "+                    }",
          "+                }",
          "+",
          "+                var data = (ulong) t;",
          "+                result |= data << (i * 16);",
          "+            }",
          "+",
          "+            return result;",
          "+        }",
          "+        ",
          "+        private static ulong E(ulong k, ulong m)",
          "+        {",
          "+            ulong state = k ^ m;",
          "+            for (int i = 0; i < Constants.C.Length - 1; i++)",
          "+            {",
          "+                k = KeySchedule(k, Constants.C[i]);",
          "+                state = L(P(S(state))) ^ k;",
          "+            }",
          "+            return state;",
          "+        }",
          "+        ",
          "+        private static ulong KeySchedule(ulong k, ulong c)",
          "+        {",
          "+            return L(P(S(k ^ c)));",
          "+        }",
          "+        ",
          "+        public static ulong G_n(ulong N, ulong h, ulong m)",
          "+        {",
          "+            return E(L(P(S(h ^ N))), m) ^ h ^ m;",
          "+        }",
          "+",
          "+        private static ulong Function(ulong N, ulong h, ulong m)",
          "+        {",
          "+            var n1 = N + 64UL;",
          "+            return G_n(n1, G_n(N, h, m), ulong.MaxValue - m + 1);",
          "+        }",
          "+",
          "+        #endregion",
          "+        ",
          "+        #region GPU G_n",
          "+        private static ulong FunctionGPU(ulong N, ulong h, ulong m)",
          "+        {",
          "+            var n1 = N + 64UL;",
          "+            return G_nGPU(n1, G_nGPU(N, h, m), ulong.MaxValue - m + 1);",
          "+        }",
          "+        ",
          "+        public static ulong G_nGPU(ulong N, ulong h, ulong m)",
          "+        {",
          "+            return EGPU(LGPU(PGPU(SGPU(h ^ N))), m) ^ h ^ m;",
          "+        }",
          "+        ",
          "+        public static ulong PGPU(ulong state)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (64 - 8 - 8 * i);",
          "+                var l = ConstTau[i * 2] % 2 == 0 ? SplitLeftByte(state, 7 - ConstTau[i * 2] / 2) : SplitRightByte(state, 7 - ConstTau[i * 2] / 2);",
          "+                var r = ConstTau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, 7 - ConstTau[i * 2 + 1] / 2) : SplitRightByte(state, 7 - ConstTau[i * 2 + 1] / 2);",
          "+                ret |= JoinBytes(l, r) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        public static ulong SGPU(ulong state)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (8 * i);",
          "+                ret |= JoinBytes(ConstSbox[SplitLeftByte(state, i)], ConstSbox[SplitRightByte(state, i)]) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        public static ulong LGPU(ulong state)",
          "+        {",
          "+            ulong result = 0;",
          "+",
          "+            for (int i = 0; i < 4; i++)",
          "+            {",
          "+                int t = 0;",
          "+                for(int k = 0; k < 16; k++) {",
          "+                    if ((state & (1UL << (k + i * 16))) != 0)",
          "+                    {",
          "+                        t ^= ConstL[16 - k - 1];",
          "+                    }",
          "+                }",
          "+",
          "+                var data = (ulong) t;",
          "+                result |= data << (i * 16);",
          "+            }",
          "+",
          "+            return result;",
          "+        }",
          "+        ",
          "+        private static ulong EGPU(ulong k, ulong m)",
          "+        {",
          "+            ulong state = k ^ m;",
          "+            for (int i = 0; i < ConstC.Length - 1; i++)",
          "+            {",
          "+                k = KeyScheduleGPU(k, ConstC[i]);",
          "+                state = LGPU(PGPU(SGPU(state))) ^ k;",
          "+            }",
          "+            return state;",
          "+        }",
          "+        ",
          "+        private static ulong KeyScheduleGPU(ulong k, ulong c)",
          "+        {",
          "+            return LGPU(PGPU(SGPU((k ^ c))));",
          "+        }",
          "+        ",
          "+",
          "+        #endregion",
          "+",
          "+        public (byte[][] messages, ulong h, ulong n) FindCollisions(int t)",
          "+        {",
          "+            var gpu = Gpu.Default;",
          "+            ",
          "+            gpu.Copy(Constants.C, ConstC);",
          "+            gpu.Copy(Constants.L, ConstL);",
          "+            gpu.Copy(Constants.SBox, ConstSbox);",
          "+            gpu.Copy(Constants.Tau, ConstTau);",
          "+",
          "+            var lst = new List<List<ulong>>();",
          "+            var solutions = new List<ulong[]>();",
          "+",
          "+            var h = 0UL;",
          "+            var n = 0UL;",
          "+",
          "+            for (int i = 0; i < t; i++)",
          "+            {",
          "+                var r = MagicPoints(n, h);",
          "+                Console.WriteLine($\"N: {n}; h: {h}\");",
          "+                Console.WriteLine($\"{r.Item1} : {r.Item2}\");",
          "+                h = Function(n, h, r.Item1);",
          "+                n += 128UL;",
          "+                lst.Add(new List<ulong>() {r.Item1, r.Item2});",
          "+            }",
          "+",
          "+            lst.Reverse();",
          "+",
          "+            var solution = new ulong[lst.Count];",
          "+            Utils.Solve(lst, solutions, solution);",
          "+            ",
          "+            var messages = solutions.Select(seq =>",
          "+            {",
          "+                IEnumerable<byte> ret = new byte[0];",
          "+",
          "+                ret = seq.Aggregate(ret, (current, value) => ",
          "+                    current.Concat(BitConverter.GetBytes(ulong.MaxValue - value + 1).Reverse())",
          "+                        .Concat(BitConverter.GetBytes(value).Reverse()));",
          "+",
          "+                return ret.ToArray();",
          "+            }).ToArray();",
          "+",
          "+            return (messages, h, n);",
          "+        }",
          "+",
          "+        private IEnumerable<byte> GetRandomByteArray(int arraySize)",
          "+        {",
          "+            byte[] buffer = new byte[arraySize];",
          "+            _rng.GetBytes(buffer);",
          "+            return buffer;",
          "+        }",
          "+",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Multicollision.cs b/Solution/Algorithm/Multicollision.cs",
          "deleted file mode 100644",
          "index ea12f0e..0000000",
          "--- a/Solution/Algorithm/Multicollision.cs",
          "+++ /dev/null",
          "@@ -1,545 +0,0 @@",
          "-\ufeffusing System;",
          "-using System.Collections.Concurrent;",
          "-using System.Collections.Generic;",
          "-using System.Diagnostics;",
          "-using System.Linq;",
          "-using System.Security.Cryptography;",
          "-using System.Threading.Tasks;",
          "-using Alea;",
          "-using Alea.Parallel;",
          "-using ServiceStack;",
          "-",
          "-namespace Algorithm",
          "-{",
          "-    public class Multicollision",
          "-    {",
          "-        private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();",
          "-",
          "-        private async Task<ulong> AsyncG_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            return await Task.Run(() => G_n(N, h, m, l, sBox, tau, c));",
          "-        }",
          "-        ",
          "-        private MagicInput GetMagic(MagicInput input, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c, int size)",
          "-        {",
          "-            var x = input.X0;",
          "-            var x0 = input.X0;",
          "-            var counter = 0;",
          "-            //if first 32 - size bits are zero, x - magic num",
          "-            while (x >> (32 + size) != 0)",
          "-            {",
          "-                x = G_n(0, h, x, l, sBox, tau, c);",
          "-                counter++;",
          "-            }",
          "-",
          "-            return new MagicInput() {X = x, X0 = x0, Counter = counter};",
          "-        }",
          "-",
          "-//        [GpuManaged]",
          "-        private MagicInput[] Cycle(MagicInput[] input, int maxSize, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            var t = (int)Math.Log(maxSize, 2);",
          "-            var result = new MagicInput[input.Length];",
          "-",
          "-            Parallel.For(0, result.Length, (i) =>",
          "-            {",
          "-                result[i] = GetMagic(input[i], h, l, sBox, tau, c, t);",
          "-//                    Console.WriteLine($\"{result[i].X} : {result[i].X0} : {result[i].Counter}\");",
          "-            });",
          "-            return result;",
          "-        }",
          "-        ",
          "-        ",
          "-        [GpuManaged]",
          "-         private MagicInput[] Cycle3(MagicInput[] input, int maxSize, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            var t = (int)Math.Log(maxSize, 2);",
          "-            var result = new MagicInput[input.Length];",
          "-            ",
          "-            Gpu.Default.For(0, result.Length, i =>",
          "-            {",
          "-                result[i] = GetMagic(input[i], h, l, sBox, tau, c, t); ",
          "-            });",
          "-            ",
          "-            return result;",
          "-        }",
          "-         ",
          "-        ",
          "-//        [GpuManaged]",
          "-        private (ulong, ulong) MagicPoints(ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            (ulong, ulong) retVal = (0, 0);",
          "-            var dict = new ConcurrentDictionary<ulong, (ulong, long)>();",
          "-            var maxSize = 1_050_000;",
          "-            var step = 10_000;",
          "-",
          "-            while (true)",
          "-            {",
          "-                Console.WriteLine(\"Begin\");",
          "-                var input = new ulong[maxSize].AsParallel().Select(data => BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0)).Select(data => new MagicInput() {X0 = data}).ToArray();",
          "-                for (int i = 0; i < maxSize; i+= step)",
          "-                {",
          "-                    var st = new Stopwatch();",
          "-                    st.Start();",
          "-                    var result = Cycle3(input.Skip(i).Take(step).ToArray(), maxSize, h, l, sBox, tau, c);",
          "-                    st.Stop();",
          "-                    var time = st.ElapsedMilliseconds;",
          "-                    Console.WriteLine(time);",
          "-                    ",
          "-                    Parallel.ForEach(result, (res, state) =>",
          "-                    {",
          "-                        var x = res.X;",
          "-                        var x0 = res.X0;",
          "-                        var count = res.Counter;",
          "-",
          "-                        if (!dict.ContainsKey(x))",
          "-                        {",
          "-                            dict[x] = (x0, count);",
          "-                        }",
          "-                        else",
          "-                        {",
          "-                            var x1 = dict[x].Item1;",
          "-                            var count1 = dict[x].Item2;",
          "-                        ",
          "-                            while (count1 > count)",
          "-                            {",
          "-                                x1 = G_n(0, h, x1, l, sBox, tau, c);",
          "-                                count1--;",
          "-                            }",
          "-",
          "-                            while (count > count1)",
          "-                            {",
          "-                                x0 = G_n(0, h, x0, l, sBox, tau, c);",
          "-                                count--;",
          "-                            }",
          "-",
          "-                            while (true)",
          "-                            {",
          "-                                var next = G_n(0, h, x1, l, sBox, tau, c);",
          "-                                var next2 = G_n(0, h, x0, l, sBox, tau, c);",
          "-",
          "-                                if (next == next2) break;",
          "-",
          "-                                x1 = next;",
          "-                                x0 = next2;",
          "-                            }",
          "-",
          "-                            if (x1 != 0 && x0 != 0)",
          "-                            {",
          "-                                retVal.Item1 = x1;",
          "-                                retVal.Item2 = x0;",
          "-                                state.Break();",
          "-                            }",
          "-                        }",
          "-                    });",
          "-",
          "-                    if (retVal != (0, 0)) break;",
          "-                }",
          "-                if (retVal != (0, 0)) break;",
          "-            }",
          "-            ",
          "-            return retVal;",
          "-        }",
          "-        ",
          "-        private (ulong, ulong) Brent(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            var power = 1;",
          "-            var lam = 1;",
          "-            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          "-  ",
          "-            var tortoise = x0;",
          "-            var hare = G_n(0, 0, x0, l, sBox, tau, c);",
          "-",
          "-            while (tortoise != hare)",
          "-            {",
          "-                if (power == lam)",
          "-                {",
          "-                    tortoise = hare;",
          "-                    power *= 2;",
          "-                    lam = 0;",
          "-                }",
          "-                hare = G_n(0, 0, hare, l, sBox, tau, c);",
          "-                lam++;",
          "-            }",
          "-            ",
          "-            tortoise = hare = x0;",
          "-",
          "-            for (int i = 0; i < lam; i++)",
          "-            {",
          "-                hare = G_n(0, 0, hare, l, sBox, tau, c);",
          "-            }",
          "-",
          "-            while (true)",
          "-            {",
          "-                var nextTask = AsyncG_n(0, 0, tortoise, l, sBox, tau, c);",
          "-                var next2Task = AsyncG_n(0, 0, hare, l, sBox, tau, c);",
          "-                            ",
          "-                Task.WaitAll(nextTask, next2Task);",
          "-                            ",
          "-                if (nextTask.Result == next2Task.Result) break;",
          "-            ",
          "-                tortoise = nextTask.Result;",
          "-                hare = next2Task.Result;",
          "-            }",
          "-",
          "-            return (tortoise, hare);",
          "-        }",
          "-        ",
          "-        private (ulong, ulong) Floyd(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          "-",
          "-            var hare = x0;",
          "-            var tortoise = x0;",
          "-",
          "-            while (true)",
          "-            {",
          "-                hare = G_n(0, 0, G_n(0, 0, hare, l, sBox, tau, c), l, sBox, tau, c);",
          "-                tortoise = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "-                ",
          "-                if (hare == tortoise)",
          "-                {",
          "-                    break;",
          "-                }",
          "-            }",
          "-",
          "-            tortoise = x0;",
          "-",
          "-            while (true)",
          "-            {",
          "-                var nextTask = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "-                var next2Task = G_n(0, 0, hare, l, sBox, tau, c);",
          "-",
          "-                if (nextTask == next2Task) break;",
          "-            }",
          "-",
          "-            return (tortoise, hare);",
          "-        } ",
          "-",
          "-        private (ulong, ulong) Algo(int N, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            var size = 64 / N;",
          "-            var Y = new ulong[size];",
          "-            var u = new ulong[size];",
          "-            var v = new ulong[size];",
          "-            Y[0] = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          "-            var m = 0UL;",
          "-            var n = 0UL;",
          "-            var w = Y[0];",
          "-",
          "-            for (int i = 1; i <= size; i++)",
          "-            {",
          "-                for (int j = (i - 1) * N + 1; j <= i * N - 1; j++)",
          "-                {",
          "-                    Y[j] = G_n(0, 0, Y[j - 1], l, sBox, tau, c);",
          "-                    if (Y[j] < w)",
          "-                    {",
          "-                        w = Y[j];",
          "-                        n = (ulong)j;",
          "-                    } else if (Y[j] == w)",
          "-                    {",
          "-                        m = (ulong)j;",
          "-",
          "-                        return (m, n);",
          "-                    }",
          "-                }",
          "-",
          "-                for (int k = 1; k <= i - 1; k++)",
          "-                {",
          "-                    if (u[k] == w)",
          "-                    {",
          "-                        m = v[k];",
          "-                        return (m, n);",
          "-                    }",
          "-                }",
          "-",
          "-                u[i] = w;",
          "-                v[i] = n;",
          "-                w = G_n(0, 0, Y[i * N - 1], l, sBox, tau, c);",
          "-                n = (ulong)(i * N);",
          "-            }",
          "-",
          "-            return (0, 0);",
          "-        }",
          "-        private static int SplitLeftByte(ulong data, int byteNum)",
          "-        {",
          "-            int shift = (8 * byteNum);",
          "-            var b = (data >> shift) & 0xff;",
          "-            return (int)(b >> 4);",
          "-        }",
          "-        ",
          "-        private static int SplitRightByte(ulong data, int byteNum)",
          "-        {",
          "-            int shift = (8 * byteNum);",
          "-            var b = (data >> shift) & 0xff;",
          "-            return (int)(b & 0xf);",
          "-        }",
          "-        ",
          "-        private static ulong JoinBytes(int hi, int low)",
          "-        {",
          "-            return (ulong)((hi << 4) | (low & 0xffffffffL));",
          "-        }",
          "-",
          "-        public static ulong P(ulong state, int[] tau)",
          "-        {",
          "-            ulong ret = 0;",
          "-            for (int i = 0; i < 8; i++)",
          "-            {",
          "-                int shift = (64 - 8 - 8 * i);",
          "-                var l = tau[i * 2] % 2 == 0 ? SplitLeftByte(state, 7 - tau[i * 2] / 2) : SplitRightByte(state, 7 - tau[i * 2] / 2);",
          "-                var r = tau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, 7 - tau[i * 2 + 1] / 2) : SplitRightByte(state, 7 - tau[i * 2 + 1] / 2);",
          "-                ret |= JoinBytes(l, r) << shift;",
          "-            }",
          "-",
          "-            return ret;",
          "-        }",
          "-        ",
          "-        public static ulong S(ulong state, int[] sBox)",
          "-        {",
          "-            ulong ret = 0;",
          "-            for (int i = 0; i < 8; i++)",
          "-            {",
          "-                int shift = (8 * i);",
          "-                ret |= JoinBytes(sBox[SplitLeftByte(state, i)], sBox[SplitRightByte(state, i)]) << shift;",
          "-            }",
          "-",
          "-            return ret;",
          "-        }",
          "-        ",
          "-        public static ulong L(ulong state, int[] lArr)",
          "-        {",
          "-            ulong result = 0;",
          "-",
          "-            for (int i = 0; i < 4; i++)",
          "-            {",
          "-                int t = 0;",
          "-                for(int k = 0; k < 16; k++) {",
          "-                    if ((state & (1UL << (k + i * 16))) != 0)",
          "-                    {",
          "-                        t ^= lArr[16 - k - 1];",
          "-                    }",
          "-                }",
          "-",
          "-                var data = (ulong) t;",
          "-                result |= data << (i * 16);",
          "-            }",
          "-",
          "-            return result;",
          "-        }",
          "-        ",
          "-        private static ulong E(ulong k, ulong m, ulong[] c, int[] l, int[] sBox, int[] tau)",
          "-        {",
          "-            ulong state = k ^ m;",
          "-            for (int i = 0; i < c.Length - 1; i++)",
          "-            {",
          "-                k = KeySchedule(k, c[i], l, sBox, tau);",
          "-                state = L(P(S(state, sBox), tau), l) ^ k;",
          "-            }",
          "-            return state;",
          "-        }",
          "-        ",
          "-        private static ulong KeySchedule(ulong k, ulong c, int[] l, int[] sBox, int[] tau)",
          "-        {",
          "-            return L(P(S((k ^ c), sBox), tau), l);",
          "-        }",
          "-        ",
          "-        public static ulong G_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "-        {",
          "-            return E(L(P(S(h ^ N, sBox), tau), l), m, c, l, sBox, tau) ^ h ^ m;",
          "-        }",
          "-        ",
          "-        public (List<ulong[]>, ulong) FindCollisions(int t)",
          "-        {",
          "-            ulong[] C =",
          "-            {",
          "-                0xc0164633575a9699,",
          "-                0x925b4ef49a5e7174,",
          "-                0x86a89cdcf673be26,",
          "-                0x1885558f0eaca3f1,",
          "-                0xdcfc5b89e35e8439,",
          "-                0x54b9edc789464d23,",
          "-                0xf80d49afde044bf9,",
          "-                0x8cbbdf71ccaa43f1,",
          "-                0xcb43af722cb520b9",
          "-            };",
          "-            int[] Tau =",
          "-            {",
          "-                0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15",
          "-            };",
          "-            int[] LArr =",
          "-            {",
          "-                0x3a22, 0x8511, 0x4b99, 0x2cdd,",
          "-                0x483b, 0x248c, 0x1246, 0x9123,",
          "-                0x59e5, 0xbd7b, 0xcfac, 0x6e56,",
          "-                0xac52, 0x56b1, 0xb3c9, 0xc86d",
          "-            };",
          "-            int[] SBox =",
          "-            {",
          "-                15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10",
          "-            };",
          "-",
          "-",
          "-//            var inp = BitConverter.GetBytes(8675695359248302480).Reverse().ToArray();",
          "-//            var r2q = BitConverter.GetBytes(G_n(0, 0, 8675695359248302480, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "-//            //BitConverter.GetBytes(G_n(0, 0, 8675695359248302480, LArr, SBox, Tau, C));",
          "-//            var r1q = mora.G_n(new byte[8], new byte[8], inp);//mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(8675695359248302480).Reverse());//new HashFunction().G_n(new byte[8], new byte[8], BitConverter.GetBytes(8675695359248302480));",
          "-",
          "-//            var size = (int) Math.Log(1_060_000, 2);",
          "-",
          "-//            var m1 = GetMagic(new MagicInput() {X0 = 8675695359248302480}, 0, LArr, SBox, Tau, C, size);",
          "-//            var m2 = GetMagic(new MagicInput() {X0 = 15975905551334951251}, 0, LArr, SBox, Tau, C, size);",
          "-",
          "-//            ulong g1 = 11580036220586509192;",
          "-",
          "-//            for (int i = 0; i < 7862; i++)",
          "-//            {",
          "-//                g1 = G_n(0, 0, g1, LArr, SBox, Tau, C);",
          "-//            }",
          "-            ",
          "-//            ulong g2 = 16100290859875211879;",
          "-",
          "-//            for (int i = 0; i <= 9202; i++)",
          "-//            {",
          "-//                g2 = G_n(0, 0, g2, LArr, SBox, Tau, C);",
          "-//            }",
          "-",
          "-",
          "-//            var t3 = MapUlongToLong(C[0]);",
          "-",
          "-//            var t2 = BitConverter.GetBytes(0xa36818bac98812b9 ^ 0x1010101010101036);",
          "-            ",
          "-//            var input = new byte[]{0xa3, 0x68, 0x18, 0xba, 0xc9, 0x88, 0x12, 0xb9};",
          "-",
          "-//            var r1 = mora.G_n(new byte[8], new byte[8], input);",
          "-//            var r2 = BitConverter.GetBytes(G_n(0, 0, BitConverter.ToUInt64(input, 0), LArr, SBox, Tau, C));",
          "-",
          "-//            var rs = mora.L(input);",
          "-            ",
          "-            ",
          "-//            var g1 = G_n(0, 12601850608120225315, 9869738958639348918, LArr, SBox, Tau, C);",
          "-//            var g1B = BitConverter.GetBytes(g1).ToArray();",
          "-//            var g2 = mora.G_n(new byte[8], BitConverter.GetBytes(12601850608120225315), BitConverter.GetBytes(9869738958639348918).ToArray());",
          "-",
          "-//            var singleCollision = MagicPoints(12601850608120225315, LArr, SBox, Tau, C);",
          "-",
          "-//            ",
          "-//            // f (B1, F(0, B0)",
          "-//            var test2 = G_n(0, G_n(0, 0, 8002912720257400307, LArr, SBox, Tau, C), 1218609768163530423, LArr, SBox, Tau,",
          "-//                C);",
          "-//            ",
          "-//            // f (B1, F(0, B0')",
          "-//            var test3 = G_n(0, G_n(0, 0, 11860533414150574761, LArr, SBox, Tau, C), 1218609768163530423, LArr, SBox, Tau,",
          "-//                C);",
          "-//            ",
          "-//            // f (B1', F(0, B0)",
          "-//            var test4 = G_n(0, G_n(0, 0, 8002912720257400307, LArr, SBox, Tau, C), 7217993951919736131, LArr, SBox, Tau,",
          "-//                C);",
          "-//            ",
          "-//            // f (B1', F(0, B0')",
          "-//            var test5 = G_n(0, G_n(0, 0, 11860533414150574761, LArr, SBox, Tau, C), 7217993951919736131, LArr, SBox, Tau,",
          "-//                C);",
          "-",
          "-//            ulong x1 = 13128198456312556595;",
          "-//            var count1 = 4281;",
          "-//            ulong x0 = 9341893395587175866;",
          "-//            var count = 2165;",
          "-//            ",
          "-//            ",
          "-//            while (count1 > count)",
          "-//            {",
          "-//                x1 = G_n(0, 0, x1, LArr, SBox, Tau, C);",
          "-//                count1--;",
          "-//            }",
          "-//",
          "-//            while (count > count1)",
          "-//            {",
          "-//                x0 = G_n(0, 0, x0, LArr, SBox, Tau, C);",
          "-//                count--;",
          "-//            }",
          "-//",
          "-//            var iterator = 0;",
          "-//            while (true)",
          "-//            {",
          "-//                var next = G_n(0, 0, x1, LArr, SBox, Tau, C);",
          "-//                var next2 = G_n(0, 0, x0, LArr, SBox, Tau, C);",
          "-//                iterator++;",
          "-//",
          "-//                if (next == next2) break;",
          "-//",
          "-//                x1 = next;",
          "-//                x0 = next2;",
          "-//            }",
          "-//",
          "-//            var test = BitConverter.GetBytes(G_n(0, 0, 1974221557608115638, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "-//            var test1 = mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(1974221557608115638).Reverse());",
          "-//            var test2 = BitConverter.GetBytes(G_n(0, 0, 8419055756211858106, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "-//            var test21 = mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(8419055756211858106).Reverse());",
          "-//            var test3 = BitConverter.GetBytes(G_n(0, 0, BitConverter.ToUInt64(new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7}.Reverse().ToArray(), 0), LArr, SBox, Tau, C)).Reverse().ToArray();",
          "-//            var test31 = mora.G_n(new byte[8], new byte[8], new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7});",
          "-",
          "-//            844909074791976",
          "-//            10270856436754831767 : 6920",
          "-//            2087758179587162062 : 2392",
          "-//            1974221557608115638 : 8419055756211858106",
          "-//            1974221557608115638 : 8419055756211858106",
          "-",
          "-//h0",
          "-//            1366367376498725",
          "-//            12214781975665660759 : 4492",
          "-//            1352692565877422794 : 5209",
          "-//            15099911268225057261 : 12827465560520173572",
          "-//            15099911268225057261 : 12827465560520173572",
          "-",
          "-//h1",
          "-//            3039673566387514",
          "-//            6490368572603814171 : 2282",
          "-//            15057135322267701395 : 7363",
          "-//            13787692588855149020 : 3806373757163530076",
          "-//            13787692588855149020 : 3806373757163530076",
          "-",
          "-            var lst = new List<List<ulong>>();",
          "-            List<ulong[]> solutions = new List<ulong[]>();",
          "-",
          "-            var h = 0UL;",
          "-            for (int i = 0; i < t; i++)",
          "-            {",
          "-                var r = MagicPoints(h, LArr, SBox, Tau, C);",
          "-                Console.WriteLine($\"{r.Item1} : {r.Item2}\");",
          "-                h = G_n(0, h, r.Item1, LArr, SBox, Tau, C);",
          "-                lst.Add(new List<ulong>() {r.Item1, r.Item2});",
          "-            }",
          "-",
          "-            ulong[] solution = new ulong[lst.Count];",
          "-            Solve(lst, solutions, solution);",
          "-",
          "-            return (solutions, h);",
          "-        }",
          "-        ",
          "-        private static void Solve(List<List<ulong>> list, List<ulong[]> solutions, ulong[] solution)",
          "-        {",
          "-            if (solution.All(i => i != 0) && !solutions.Any(s => s.SequenceEqual(solution)))",
          "-                solutions.Add(solution);",
          "-            for (int i = 0; i < list.Count; i++)",
          "-            {",
          "-                if (solution[i] != 0)",
          "-                    continue; // a caller up the hierarchy set this index to be a number",
          "-                for (int j = 0; j < list[i].Count; j++)",
          "-                {",
          "-                    if (solution.Contains(list[i][j]))",
          "-                        continue;",
          "-                    var solutionCopy = solution.ToArray();",
          "-                    solutionCopy[i] = list[i][j];",
          "-                    Solve(list, solutions, solutionCopy);",
          "-                }",
          "-            }",
          "-        }",
          "-",
          "-        private IEnumerable<byte> GetRandomByteArray(int arraySize)",
          "-        {",
          "-            byte[] buffer = new byte[arraySize];",
          "-            _rng.GetBytes(buffer);",
          "-            return buffer;",
          "-        }",
          "-",
          "-    }",
          "-}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Program.cs b/Solution/Algorithm/Program.cs",
          "index 7d410d5..a1b2969 100644",
          "--- a/Solution/Algorithm/Program.cs",
          "+++ b/Solution/Algorithm/Program.cs",
          "@@ -39,13 +39,14 @@ namespace Algorithm",
          " ",
          " //            var resultHash = hash.ComputeHash(File.ReadAllBytes(result.Value.OutputFile));",
          " ",
          "-            var collisions = new Multicollision();",
          "-            var messages = collisions.FindCollisions(result.Value.T);",
          "+            var collisions = new MultiCollisions();",
          "+            var (messages, h, n) = collisions.FindCollisions(10);",
          " ",
          "             using (var sw = File.CreateText(result.Value.OutputFile))",
          "             {",
          "-                sw.WriteLine($\"h = {BitConverter.ToString(BitConverter.GetBytes(messages.Item2).Reverse().ToArray()).Replace(\"-\", string.Empty)}\");",
          "-                messages.Item1.Select(msg => msg.SelectMany(m => BitConverter.GetBytes(m).Reverse())).ForEach(msg =>",
          "+                sw.WriteLine($\"h = {HashFunction.StringRepresentation(BitConverter.GetBytes(h).Reverse().ToArray())}\");",
          "+                sw.WriteLine($\"n = {HashFunction.StringRepresentation(BitConverter.GetBytes(n).Reverse().ToArray())}\");",
          "+                messages.ForEach(msg =>",
          "                 {",
          "                     sw.WriteLine(HashFunction.StringRepresentation(msg.ToArray()));",
          "                 });  ",
          "diff --git a/Solution/Algorithm/Utils.cs b/Solution/Algorithm/Utils.cs",
          "new file mode 100644",
          "index 0000000..71042a3",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/Utils.cs",
          "@@ -0,0 +1,33 @@",
          "+\ufeffusing System.Collections.Generic;",
          "+using System.Linq;",
          "+",
          "+namespace Algorithm",
          "+{",
          "+    public class Utils",
          "+    {",
          "+        /// <summary>",
          "+        /// \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0432 solutions 2^t \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438\u0437 t \u043f\u0430\u0440",
          "+        /// </summary>",
          "+        /// <param name=\"list\"></param>",
          "+        /// <param name=\"solutions\"></param>",
          "+        /// <param name=\"solution\"></param>",
          "+        public static void Solve(List<List<ulong>> list, List<ulong[]> solutions, ulong[] solution)",
          "+        {",
          "+            if (solution.All(i => i != 0) && !solutions.Any(s => s.SequenceEqual(solution)))",
          "+                solutions.Add(solution);",
          "+            for (int i = 0; i < list.Count; i++)",
          "+            {",
          "+                if (solution[i] != 0)",
          "+                    continue; // a caller up the hierarchy set this index to be a number",
          "+                for (int j = 0; j < list[i].Count; j++)",
          "+                {",
          "+                    if (solution.Contains(list[i][j]))",
          "+                        continue;",
          "+                    var solutionCopy = solution.ToArray();",
          "+                    solutionCopy[i] = list[i][j];",
          "+                    Solve(list, solutions, solutionCopy);",
          "+                }",
          "+            }",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash.Tests/TestMoraHash.cs b/Solution/MoraHash.Tests/TestMoraHash.cs",
          "index 76d8d45..50d26bf 100644",
          "--- a/Solution/MoraHash.Tests/TestMoraHash.cs",
          "+++ b/Solution/MoraHash.Tests/TestMoraHash.cs",
          "@@ -17,8 +17,7 @@ namespace MoraHash.Tests",
          "             var mora = new HashFunction();",
          "             ",
          "             var result = mora.G_n(new byte[8], new byte[8], m);",
          "-            var resultMultiCol = Multicollision.G_n(0, 0, BitConverter.ToUInt64(m.Reverse().ToArray(), 0), Constants.L,",
          "-                Constants.SBox, Constants.Tau, Constants.C);",
          "+            var resultMultiCol = MultiCollisions.G_n(0, 0, BitConverter.ToUInt64(m.Reverse().ToArray(), 0));",
          "             ",
          "             Assert.True(expected.SequenceEqual(result));",
          "             Assert.True(expected.SequenceEqual(BitConverter.GetBytes(resultMultiCol).Reverse()));",
          "diff --git a/Solution/MoraHash/HashFunction.cs b/Solution/MoraHash/HashFunction.cs",
          "index a9cdd47..99fac4d 100644",
          "--- a/Solution/MoraHash/HashFunction.cs",
          "+++ b/Solution/MoraHash/HashFunction.cs",
          "@@ -88,6 +88,8 @@ namespace MoraHash",
          "         private byte[] GetHash(byte[] message)",
          "         {",
          "             var h = new byte[BlockSize];",
          "+            _n = new byte[BlockSize];",
          "+            _sigma = new byte[BlockSize];",
          "             Array.Copy(_iv, h, BlockSize);",
          " ",
          "             byte[] n0 = new byte[BlockSize];",
          "diff --git a/Solution/Multicollisions.sln b/Solution/Multicollisions.sln",
          "index 2a2066b..82291c3 100644",
          "--- a/Solution/Multicollisions.sln",
          "+++ b/Solution/Multicollisions.sln",
          "@@ -9,6 +9,8 @@ Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash.Tests\", \"MoraHash.",
          " EndProject",
          " Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{98508736-247B-41BB-9221-70C900431B19}\"",
          " EndProject",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Algorithm.Tests\", \"Algorithm.Tests\\Algorithm.Tests.csproj\", \"{061ED14B-8389-4CE0-9D3B-373D8FABCA50}\"",
          "+EndProject",
          " Global",
          " \tGlobalSection(SolutionConfigurationPlatforms) = preSolution",
          " \t\tDebug|Any CPU = Debug|Any CPU",
          "@@ -41,6 +43,14 @@ Global",
          " \t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.Build.0 = Release|Any CPU",
          " \t\t{98508736-247B-41BB-9221-70C900431B19}.Release|x64.ActiveCfg = Release|x64",
          " \t\t{98508736-247B-41BB-9221-70C900431B19}.Release|x64.Build.0 = Release|x64",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Debug|x64.ActiveCfg = Debug|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Debug|x64.Build.0 = Debug|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Release|x64.ActiveCfg = Release|Any CPU",
          "+\t\t{061ED14B-8389-4CE0-9D3B-373D8FABCA50}.Release|x64.Build.0 = Release|Any CPU",
          " \tEndGlobalSection",
          " \tGlobalSection(SolutionProperties) = preSolution",
          " \t\tHideSolutionNode = FALSE",
          ""
        ],
        "7650f7d5f923c36d54b2c70e39361386e73599dd": [
          "commit 7650f7d5f923c36d54b2c70e39361386e73599dd",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Tue Dec 29 14:50:49 2020 +0300",
          "",
          "    refactor",
          "",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "index 2eb515a..09d8d43 100644",
          "--- a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "@@ -1,18 +1,6 @@",
          " <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          " <project version=\"4\">",
          "   <component name=\"ContentModelStore\">",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\ru\" t=\"Include\">",
          "-      <e p=\"Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.resources.dll\" t=\"Include\" />",
          "-      <e p=\"Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.resources.dll\" t=\"Include\" />",
          "-      <e p=\"Microsoft.VisualStudio.TestPlatform.TestFramework.resources.dll\" t=\"Include\" />",
          "-    </e>",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.abstractions.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.reporters.net452.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.utility.net452.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.visualstudio.testadapter.dll\" t=\"Include\" />",
          "     <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\extResources\" t=\"IncludeRecursive\" />",
          "     <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\resharper-host\\local\\Transient\\ReSharperHost\\v192\\SolutionCaches\\_Multicollisions.-582165928.00\" t=\"ExcludeRecursive\" />",
          "     <e p=\"C:\\Users\\niktv\\RiderProjects\\Multicollisions\\Solution\" t=\"IncludeFlat\">",
          "@@ -23,10 +11,8 @@",
          "         <e p=\"FodyWeavers.xml\" t=\"Include\" />",
          "         <e p=\"MagicInput.cs\" t=\"Include\" />",
          "         <e p=\"Multicollision.cs\" t=\"Include\" />",
          "-        <e p=\"NewFile1.txt\" t=\"Include\" />",
          "         <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "         <e p=\"Options.cs\" t=\"Include\" />",
          "-        <e p=\"ParallelForDelegateTest.cs\" t=\"Include\" />",
          "         <e p=\"Program.cs\" t=\"Include\" />",
          "         <e p=\"Properties\" t=\"Include\">",
          "           <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "@@ -46,16 +32,12 @@",
          "       <e p=\"MoraHash.Tests\" t=\"IncludeRecursive\">",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "         <e p=\"MoraHash.Tests.csproj\" t=\"IncludeRecursive\" />",
          "-        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "-          <e p=\"x64\" t=\"Include\">",
          "-            <e p=\"Debug\" t=\"Include\">",
          "-              <e p=\"net472\" t=\"Include\">",
          "-                <e p=\"MoraHash.Tests.AssemblyInfo.cs\" t=\"Include\" />",
          "-              </e>",
          "-            </e>",
          "-          </e>",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"packages.config\" t=\"Include\" />",
          "+        <e p=\"Properties\" t=\"Include\">",
          "+          <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "         </e>",
          "-        <e p=\"TestHash.cs\" t=\"Include\" />",
          "+        <e p=\"TestMoraHash.cs\" t=\"Include\" />",
          "       </e>",
          "       <e p=\"Multicollisions.sln\" t=\"IncludeFlat\" />",
          "       <e p=\"packages\" t=\"ExcludeRecursive\" />",
          "diff --git a/Solution/Algorithm/Algorithm.csproj b/Solution/Algorithm/Algorithm.csproj",
          "index d38c337..1101677 100644",
          "--- a/Solution/Algorithm/Algorithm.csproj",
          "+++ b/Solution/Algorithm/Algorithm.csproj",
          "@@ -36,25 +36,6 @@",
          "     <PlatformTarget>x64</PlatformTarget>",
          "   </PropertyGroup>",
          "   <ItemGroup>",
          "-    <!--    <Reference Include=\"Alea, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "-    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.dll</HintPath>-->",
          "-    <!--      <Private>True</Private>-->",
          "-    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "-    <!--    </Reference>-->",
          "-    <!--    <Reference Include=\"Alea.IL, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "-    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.IL.dll</HintPath>-->",
          "-    <!--      <Private>True</Private>-->",
          "-    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "-    <!--    </Reference>-->",
          "-    <!--    <Reference Include=\"Alea.Parallel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "-    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.Parallel.dll</HintPath>-->",
          "-    <!--      <Private>True</Private>-->",
          "-    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "-    <!--    </Reference>-->",
          "-    <!--    <Reference Include=\"FSharp.Core, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\">-->",
          "-    <!--      <HintPath>..\\packages\\FSharp.Core.5.0.0\\lib\\netstandard2.0\\FSharp.Core.dll</HintPath>-->",
          "-    <!--      <Private>True</Private>-->",
          "-    <!--    </Reference>-->",
          "     <Reference Include=\"System\" />",
          "     <Reference Include=\"System.Core\" />",
          "     <Reference Include=\"System.Data\" />",
          "@@ -64,13 +45,11 @@",
          "     <Compile Include=\"MagicInput.cs\" />",
          "     <Compile Include=\"Multicollision.cs\" />",
          "     <Compile Include=\"Options.cs\" />",
          "-    <Compile Include=\"ParallelForDelegateTest.cs\" />",
          "     <Compile Include=\"Program.cs\" />",
          "     <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "   </ItemGroup>",
          "   <ItemGroup>",
          "     <Content Include=\"FodyWeavers.xml\" />",
          "-    <Content Include=\"NewFile1.txt\" />",
          "   </ItemGroup>",
          "   <ItemGroup>",
          "     <None Include=\"App.config\" />",
          "@@ -95,23 +74,4 @@",
          "     <Target Name=\"AfterBuild\">",
          "     </Target>",
          "     -->",
          "-</Project>",
          "-<!--<Project Sdk=\"Microsoft.NET.Sdk\">-->",
          "-<!--    <PropertyGroup>-->",
          "-<!--        <OutputType>Exe</OutputType>-->",
          "-<!--        <TargetFramework>net472</TargetFramework>-->",
          "-<!--    </PropertyGroup>-->",
          "-<!--    <ItemGroup>-->",
          "-<!--      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />-->",
          "-<!--    </ItemGroup>-->",
          "-<!--    <ItemGroup>-->",
          "-<!--      <PackageReference Include=\"Alea\" Version=\"3.0.4\" />-->",
          "-<!--      <PackageReference Include=\"Alea.Fody\" Version=\"3.0.4\">-->",
          "-<!--        <PrivateAssets>all</PrivateAssets>-->",
          "-<!--        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>-->",
          "-<!--      </PackageReference>-->",
          "-<!--      <PackageReference Include=\"CommandLineParser\" Version=\"2.9.0-preview1\" />-->",
          "-<!--      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />-->",
          "-<!--      <PackageReference Include=\"ServiceStack.Common\" Version=\"5.10.2\" />-->",
          "-<!--    </ItemGroup>-->",
          "-<!--</Project>-->",
          "\\ No newline at end of file",
          "+</Project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/App.config b/Solution/Algorithm/App.config",
          "index dad07ac..5a9a3a4 100644",
          "--- a/Solution/Algorithm/App.config",
          "+++ b/Solution/Algorithm/App.config",
          "@@ -9,6 +9,7 @@",
          "         <resource path=\"@base\" assemblyPath=\"@base\"/>",
          "         <cuBLAS version=\"8.0\"/>",
          "         <cuRAND version=\"8.0\"/>",
          "+        <jitCompile level=\"Diagnostic\"/>",
          "     </aleaSettings>",
          "     <startup>",
          "         <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.7.2\" />",
          "diff --git a/Solution/Algorithm/Multicollision.cs b/Solution/Algorithm/Multicollision.cs",
          "index d55dc43..ea12f0e 100644",
          "--- a/Solution/Algorithm/Multicollision.cs",
          "+++ b/Solution/Algorithm/Multicollision.cs",
          "@@ -1,25 +1,13 @@",
          " \ufeffusing System;",
          "-using System.Collections;",
          " using System.Collections.Concurrent;",
          " using System.Collections.Generic;",
          " using System.Diagnostics;",
          " using System.Linq;",
          "-using System.Reflection;",
          " using System.Security.Cryptography;",
          "-using System.Security.Cryptography.X509Certificates;",
          "-using System.Text;",
          "-using System.Threading;",
          " using System.Threading.Tasks;",
          " using Alea;",
          "-using Alea.CSharp;",
          "-using Alea.cuRAND;",
          " using Alea.Parallel;",
          "-using Microsoft.VisualBasic;",
          "-using MoraHash;",
          "-using MoreLinq;",
          "-using MoreLinq.Extensions;",
          " using ServiceStack;",
          "-using ServiceStack.Logging;",
          " ",
          " namespace Algorithm",
          " {",
          "@@ -34,73 +22,70 @@ namespace Algorithm",
          "         ",
          "         private MagicInput GetMagic(MagicInput input, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c, int size)",
          "         {",
          "+            var x = input.X0;",
          "             var x0 = input.X0;",
          "-            var x = G_n(0, h, x0, l, sBox, tau, c);",
          "-            long counter = 0;",
          "-",
          "-            //if first 16 bits are zero, x - magic num",
          "+            var counter = 0;",
          "+            //if first 32 - size bits are zero, x - magic num",
          "             while (x >> (32 + size) != 0)",
          "             {",
          "                 x = G_n(0, h, x, l, sBox, tau, c);",
          "                 counter++;",
          "             }",
          "+",
          "             return new MagicInput() {X = x, X0 = x0, Counter = counter};",
          "         }",
          " ",
          "-        [GpuManaged]",
          "-        private MagicInput[] Cycle(ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+//        [GpuManaged]",
          "+        private MagicInput[] Cycle(MagicInput[] input, int maxSize, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "         {",
          "-            var size = 100_000;",
          "-            var t = (int)Math.Log(size, 2);",
          "-            var input = new ulong[size].AsParallel().Select(data => BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0)).Select(data => new MagicInput() {X0 = data}).ToArray();",
          "-            var result = new MagicInput[size];",
          "+            var t = (int)Math.Log(maxSize, 2);",
          "+            var result = new MagicInput[input.Length];",
          " ",
          "-//            Gpu.Default.For(0, size, i =>",
          "-//            {",
          "-//                result[i] = GetMagic(input[i], l, sBox, tau, c);",
          "-//            });",
          "-//            new Thread(() =>",
          "-//            {",
          "-                            Gpu.Default.For(0, size, i =>",
          "+            Parallel.For(0, result.Length, (i) =>",
          "             {",
          "                 result[i] = GetMagic(input[i], h, l, sBox, tau, c, t);",
          "+//                    Console.WriteLine($\"{result[i].X} : {result[i].X0} : {result[i].Counter}\");",
          "+            });",
          "+            return result;",
          "+        }",
          "+        ",
          "+        ",
          "+        [GpuManaged]",
          "+         private MagicInput[] Cycle3(MagicInput[] input, int maxSize, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var t = (int)Math.Log(maxSize, 2);",
          "+            var result = new MagicInput[input.Length];",
          "+            ",
          "+            Gpu.Default.For(0, result.Length, i =>",
          "+            {",
          "+                result[i] = GetMagic(input[i], h, l, sBox, tau, c, t); ",
          "             });",
          "-//                Parallel.For(0, size, (i) => { result[i] = GetMagic(input[i], l, sBox, tau, c, t); });",
          "-//            }).Start();",
          "             ",
          "-",
          "             return result;",
          "         }",
          "+         ",
          "         ",
          " //        [GpuManaged]",
          "         private (ulong, ulong) MagicPoints(ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "         {",
          "-            Console.WriteLine(\"Begin\");",
          "             (ulong, ulong) retVal = (0, 0);",
          "             var dict = new ConcurrentDictionary<ulong, (ulong, long)>();",
          "+            var maxSize = 1_050_000;",
          "+            var step = 10_000;",
          " ",
          "             while (true)",
          "             {",
          "-                var result = Cycle(h, l, sBox, tau, c);",
          "-//                var usedIndexes = new bool[result.Length];",
          "-//                while (!usedIndexes.All(i => i))",
          "-//                {",
          "-//                    var tmpResult = result.Where((res, i) =>",
          "-//                    {",
          "-//                        if (res.X == 0 && res.X0 == 0 || usedIndexes[i]) return false;",
          "-//",
          "-//                        usedIndexes[i] = true;",
          "-//                        return true;",
          "-//                    }).ToArray();",
          "-//",
          "-//                    if (!tmpResult.Any())",
          "-//                    {",
          "-//                        Thread.Sleep(5 * 60 * 1000);",
          "-//                        continue;",
          "-//                    }",
          "-//                    ",
          "-//                    Console.WriteLine($\"{usedIndexes.Count(i => i)}\");",
          "-",
          "+                Console.WriteLine(\"Begin\");",
          "+                var input = new ulong[maxSize].AsParallel().Select(data => BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0)).Select(data => new MagicInput() {X0 = data}).ToArray();",
          "+                for (int i = 0; i < maxSize; i+= step)",
          "+                {",
          "+                    var st = new Stopwatch();",
          "+                    st.Start();",
          "+                    var result = Cycle3(input.Skip(i).Take(step).ToArray(), maxSize, h, l, sBox, tau, c);",
          "+                    st.Stop();",
          "+                    var time = st.ElapsedMilliseconds;",
          "+                    Console.WriteLine(time);",
          "+                    ",
          "                     Parallel.ForEach(result, (res, state) =>",
          "                     {",
          "                         var x = res.X;",
          "@@ -115,7 +100,7 @@ namespace Algorithm",
          "                         {",
          "                             var x1 = dict[x].Item1;",
          "                             var count1 = dict[x].Item2;",
          "-",
          "+                        ",
          "                             while (count1 > count)",
          "                             {",
          "                                 x1 = G_n(0, h, x1, l, sBox, tau, c);",
          "@@ -132,23 +117,27 @@ namespace Algorithm",
          "                             {",
          "                                 var next = G_n(0, h, x1, l, sBox, tau, c);",
          "                                 var next2 = G_n(0, h, x0, l, sBox, tau, c);",
          "-                                ",
          "+",
          "                                 if (next == next2) break;",
          " ",
          "                                 x1 = next;",
          "                                 x0 = next2;",
          "                             }",
          " ",
          "-                            retVal.Item1 = x1;",
          "-                            retVal.Item2 = x0;",
          "-                            state.Break();",
          "+                            if (x1 != 0 && x0 != 0)",
          "+                            {",
          "+                                retVal.Item1 = x1;",
          "+                                retVal.Item2 = x0;",
          "+                                state.Break();",
          "+                            }",
          "                         }",
          "                     });",
          "-                ",
          "+",
          "+                    if (retVal != (0, 0)) break;",
          "+                }",
          "                 if (retVal != (0, 0)) break;",
          "             }",
          "-",
          "-//            Console.WriteLine($\"{retVal.Item1} : {retVal.Item2}\");",
          "+            ",
          "             return retVal;",
          "         }",
          "         ",
          "@@ -156,7 +145,7 @@ namespace Algorithm",
          "         {",
          "             var power = 1;",
          "             var lam = 1;",
          "-            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          "   ",
          "             var tortoise = x0;",
          "             var hare = G_n(0, 0, x0, l, sBox, tau, c);",
          "@@ -198,7 +187,7 @@ namespace Algorithm",
          "         ",
          "         private (ulong, ulong) Floyd(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "         {",
          "-            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          " ",
          "             var hare = x0;",
          "             var tortoise = x0;",
          "@@ -207,10 +196,6 @@ namespace Algorithm",
          "             {",
          "                 hare = G_n(0, 0, G_n(0, 0, hare, l, sBox, tau, c), l, sBox, tau, c);",
          "                 tortoise = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "-",
          "-//                Task.WaitAll(hareTask, tortoiseTask);",
          "-//                hare = hareTask.Result;",
          "-//                tortoise = tortoiseTask.Result;",
          "                 ",
          "                 if (hare == tortoise)",
          "                 {",
          "@@ -224,9 +209,7 @@ namespace Algorithm",
          "             {",
          "                 var nextTask = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "                 var next2Task = G_n(0, 0, hare, l, sBox, tau, c);",
          "-                ",
          "-//                Task.WaitAll(nextTask, next2Task);",
          "-                ",
          "+",
          "                 if (nextTask == next2Task) break;",
          "             }",
          " ",
          "@@ -239,7 +222,7 @@ namespace Algorithm",
          "             var Y = new ulong[size];",
          "             var u = new ulong[size];",
          "             var v = new ulong[size];",
          "-            Y[0] = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+            Y[0] = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray(8).ToArray(), 0), l, sBox, tau, c);",
          "             var m = 0UL;",
          "             var n = 0UL;",
          "             var w = Y[0];",
          "@@ -277,55 +260,41 @@ namespace Algorithm",
          "             }",
          " ",
          "             return (0, 0);",
          "-        } ",
          "-        ",
          "-        private ulong GCD(ulong a, ulong b)",
          "-        {",
          "-            while (a != 0 && b != 0)",
          "-            {",
          "-                if (a > b)",
          "-                    a %= b;",
          "-                else",
          "-                    b %= a;",
          "-            }",
          "-",
          "-            return a | b;",
          "         }",
          "-",
          "-        private int SplitLeftByte(ulong data, int byteNum)",
          "+        private static int SplitLeftByte(ulong data, int byteNum)",
          "         {",
          "             int shift = (8 * byteNum);",
          "             var b = (data >> shift) & 0xff;",
          "             return (int)(b >> 4);",
          "         }",
          "         ",
          "-        private int SplitRightByte(ulong data, int byteNum)",
          "+        private static int SplitRightByte(ulong data, int byteNum)",
          "         {",
          "             int shift = (8 * byteNum);",
          "             var b = (data >> shift) & 0xff;",
          "             return (int)(b & 0xf);",
          "         }",
          "         ",
          "-        private ulong JoinBytes(int hi, int low)",
          "+        private static ulong JoinBytes(int hi, int low)",
          "         {",
          "             return (ulong)((hi << 4) | (low & 0xffffffffL));",
          "         }",
          " ",
          "-        public ulong P(ulong state, int[] tau)",
          "+        public static ulong P(ulong state, int[] tau)",
          "         {",
          "             ulong ret = 0;",
          "             for (int i = 0; i < 8; i++)",
          "             {",
          "-                int shift = (8 * i);",
          "-                var l = tau[i * 2] % 2 == 0 ? SplitLeftByte(state, tau[i * 2] / 2) : SplitRightByte(state, tau[i * 2] / 2);",
          "-                var r = tau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, tau[i * 2 + 1] / 2) : SplitRightByte(state, tau[i * 2 + 1] / 2);",
          "+                int shift = (64 - 8 - 8 * i);",
          "+                var l = tau[i * 2] % 2 == 0 ? SplitLeftByte(state, 7 - tau[i * 2] / 2) : SplitRightByte(state, 7 - tau[i * 2] / 2);",
          "+                var r = tau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, 7 - tau[i * 2 + 1] / 2) : SplitRightByte(state, 7 - tau[i * 2 + 1] / 2);",
          "                 ret |= JoinBytes(l, r) << shift;",
          "             }",
          " ",
          "             return ret;",
          "         }",
          "         ",
          "-        private ulong S(ulong state, int[] sBox)",
          "+        public static ulong S(ulong state, int[] sBox)",
          "         {",
          "             ulong ret = 0;",
          "             for (int i = 0; i < 8; i++)",
          "@@ -337,73 +306,56 @@ namespace Algorithm",
          "             return ret;",
          "         }",
          "         ",
          "-        public ulong L(ulong state, int[] l)",
          "+        public static ulong L(ulong state, int[] lArr)",
          "         {",
          "             ulong result = 0;",
          " ",
          "             for (int i = 0; i < 4; i++)",
          "             {",
          "                 int t = 0;",
          "-                var tmp = (int) ((state >> (i * 2 + 1 << 3)) & 0xFF) << (8 * i + 1 << 3) |",
          "-                          (int) ((state >> (i * 2 << 3)) & 0xFF);",
          "-                ",
          "-                for(int k = 0; k < 16; k++){",
          "-                    int mask =  1 << k;",
          "-                    int masked_n = tmp & mask;",
          "-                    int thebit = masked_n >> k;",
          "-",
          "-                    if (k < 8)",
          "+                for(int k = 0; k < 16; k++) {",
          "+                    if ((state & (1UL << (k + i * 16))) != 0)",
          "                     {",
          "-                        if (thebit == 1)",
          "-                            t ^= l[8 - k - 1];",
          "-                    }",
          "-                    else",
          "-                    {",
          "-                        if (thebit == 1)",
          "-                            t ^= l[24 - k - 1];",
          "+                        t ^= lArr[16 - k - 1];",
          "                     }",
          "                 }",
          " ",
          "                 var data = (ulong) t;",
          "-                result |= (data >> 8 | ((data & 0xFF) << 8)) << i * 16;",
          "+                result |= data << (i * 16);",
          "             }",
          " ",
          "             return result;",
          "         }",
          "         ",
          "-        private ulong E(ulong k, ulong m, ulong[] c, int[] l, int[] sBox, int[] tau)",
          "+        private static ulong E(ulong k, ulong m, ulong[] c, int[] l, int[] sBox, int[] tau)",
          "         {",
          "             ulong state = k ^ m;",
          "-            for (int i = 0; i < c.Length; i++)",
          "+            for (int i = 0; i < c.Length - 1; i++)",
          "             {",
          "-                state = L(P(S(state, sBox), tau), l) ^ KeySchedule(k, c[i], l, sBox, tau);",
          "+                k = KeySchedule(k, c[i], l, sBox, tau);",
          "+                state = L(P(S(state, sBox), tau), l) ^ k;",
          "             }",
          "             return state;",
          "         }",
          "         ",
          "-        private ulong KeySchedule(ulong k, ulong c, int[] l, int[] sBox, int[] tau)",
          "+        private static ulong KeySchedule(ulong k, ulong c, int[] l, int[] sBox, int[] tau)",
          "         {",
          "             return L(P(S((k ^ c), sBox), tau), l);",
          "         }",
          "         ",
          "-        public ulong G_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        public static ulong G_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "         {",
          "             return E(L(P(S(h ^ N, sBox), tau), l), m, c, l, sBox, tau) ^ h ^ m;",
          "         }",
          "         ",
          "-",
          "-",
          "-//        [GpuManaged]",
          "-        public void FindCollisions()",
          "+        public (List<ulong[]>, ulong) FindCollisions(int t)",
          "         {",
          "-            var mora = new HashFunction();",
          "-            ",
          "             ulong[] C =",
          "             {",
          "                 0xc0164633575a9699,",
          "                 0x925b4ef49a5e7174,",
          "                 0x86a89cdcf673be26,",
          "-                0x86a89cdcf673be26,",
          "+                0x1885558f0eaca3f1,",
          "                 0xdcfc5b89e35e8439,",
          "                 0x54b9edc789464d23,",
          "                 0xf80d49afde044bf9,",
          "@@ -416,47 +368,178 @@ namespace Algorithm",
          "             };",
          "             int[] LArr =",
          "             {",
          "-                0x3a22, 0x483b, 0x59e5, 0xac52,",
          "-                0x8511, 0x248c, 0xbd7b, 0x56b1,",
          "-                0x4b99, 0x1246, 0xcfac, 0xb3c9,",
          "-                0x2cdd, 0x9123, 0x6e56 ,0xc86d",
          "+                0x3a22, 0x8511, 0x4b99, 0x2cdd,",
          "+                0x483b, 0x248c, 0x1246, 0x9123,",
          "+                0x59e5, 0xbd7b, 0xcfac, 0x6e56,",
          "+                0xac52, 0x56b1, 0xb3c9, 0xc86d",
          "             };",
          "             int[] SBox =",
          "             {",
          "                 15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10",
          "             };",
          " ",
          "-            var singleCollision = MagicPoints(12601850608120225315, LArr, SBox, Tau, C);",
          " ",
          "-            int a = 0;",
          "+//            var inp = BitConverter.GetBytes(8675695359248302480).Reverse().ToArray();",
          "+//            var r2q = BitConverter.GetBytes(G_n(0, 0, 8675695359248302480, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "+//            //BitConverter.GetBytes(G_n(0, 0, 8675695359248302480, LArr, SBox, Tau, C));",
          "+//            var r1q = mora.G_n(new byte[8], new byte[8], inp);//mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(8675695359248302480).Reverse());//new HashFunction().G_n(new byte[8], new byte[8], BitConverter.GetBytes(8675695359248302480));",
          " ",
          "+//            var size = (int) Math.Log(1_060_000, 2);",
          " ",
          "-        }",
          "+//            var m1 = GetMagic(new MagicInput() {X0 = 8675695359248302480}, 0, LArr, SBox, Tau, C, size);",
          "+//            var m2 = GetMagic(new MagicInput() {X0 = 15975905551334951251}, 0, LArr, SBox, Tau, C, size);",
          " ",
          "-        private IEnumerable<byte[]> GetRandomByteArray(int arraySize)",
          "-        {",
          "-            for (int i = 0; i < 10_000; i++)",
          "+//            ulong g1 = 11580036220586509192;",
          "+",
          "+//            for (int i = 0; i < 7862; i++)",
          "+//            {",
          "+//                g1 = G_n(0, 0, g1, LArr, SBox, Tau, C);",
          "+//            }",
          "+            ",
          "+//            ulong g2 = 16100290859875211879;",
          "+",
          "+//            for (int i = 0; i <= 9202; i++)",
          "+//            {",
          "+//                g2 = G_n(0, 0, g2, LArr, SBox, Tau, C);",
          "+//            }",
          "+",
          "+",
          "+//            var t3 = MapUlongToLong(C[0]);",
          "+",
          "+//            var t2 = BitConverter.GetBytes(0xa36818bac98812b9 ^ 0x1010101010101036);",
          "+            ",
          "+//            var input = new byte[]{0xa3, 0x68, 0x18, 0xba, 0xc9, 0x88, 0x12, 0xb9};",
          "+",
          "+//            var r1 = mora.G_n(new byte[8], new byte[8], input);",
          "+//            var r2 = BitConverter.GetBytes(G_n(0, 0, BitConverter.ToUInt64(input, 0), LArr, SBox, Tau, C));",
          "+",
          "+//            var rs = mora.L(input);",
          "+            ",
          "+            ",
          "+//            var g1 = G_n(0, 12601850608120225315, 9869738958639348918, LArr, SBox, Tau, C);",
          "+//            var g1B = BitConverter.GetBytes(g1).ToArray();",
          "+//            var g2 = mora.G_n(new byte[8], BitConverter.GetBytes(12601850608120225315), BitConverter.GetBytes(9869738958639348918).ToArray());",
          "+",
          "+//            var singleCollision = MagicPoints(12601850608120225315, LArr, SBox, Tau, C);",
          "+",
          "+//            ",
          "+//            // f (B1, F(0, B0)",
          "+//            var test2 = G_n(0, G_n(0, 0, 8002912720257400307, LArr, SBox, Tau, C), 1218609768163530423, LArr, SBox, Tau,",
          "+//                C);",
          "+//            ",
          "+//            // f (B1, F(0, B0')",
          "+//            var test3 = G_n(0, G_n(0, 0, 11860533414150574761, LArr, SBox, Tau, C), 1218609768163530423, LArr, SBox, Tau,",
          "+//                C);",
          "+//            ",
          "+//            // f (B1', F(0, B0)",
          "+//            var test4 = G_n(0, G_n(0, 0, 8002912720257400307, LArr, SBox, Tau, C), 7217993951919736131, LArr, SBox, Tau,",
          "+//                C);",
          "+//            ",
          "+//            // f (B1', F(0, B0')",
          "+//            var test5 = G_n(0, G_n(0, 0, 11860533414150574761, LArr, SBox, Tau, C), 7217993951919736131, LArr, SBox, Tau,",
          "+//                C);",
          "+",
          "+//            ulong x1 = 13128198456312556595;",
          "+//            var count1 = 4281;",
          "+//            ulong x0 = 9341893395587175866;",
          "+//            var count = 2165;",
          "+//            ",
          "+//            ",
          "+//            while (count1 > count)",
          "+//            {",
          "+//                x1 = G_n(0, 0, x1, LArr, SBox, Tau, C);",
          "+//                count1--;",
          "+//            }",
          "+//",
          "+//            while (count > count1)",
          "+//            {",
          "+//                x0 = G_n(0, 0, x0, LArr, SBox, Tau, C);",
          "+//                count--;",
          "+//            }",
          "+//",
          "+//            var iterator = 0;",
          "+//            while (true)",
          "+//            {",
          "+//                var next = G_n(0, 0, x1, LArr, SBox, Tau, C);",
          "+//                var next2 = G_n(0, 0, x0, LArr, SBox, Tau, C);",
          "+//                iterator++;",
          "+//",
          "+//                if (next == next2) break;",
          "+//",
          "+//                x1 = next;",
          "+//                x0 = next2;",
          "+//            }",
          "+//",
          "+//            var test = BitConverter.GetBytes(G_n(0, 0, 1974221557608115638, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "+//            var test1 = mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(1974221557608115638).Reverse());",
          "+//            var test2 = BitConverter.GetBytes(G_n(0, 0, 8419055756211858106, LArr, SBox, Tau, C)).Reverse().ToArray();",
          "+//            var test21 = mora.G_n(new byte[8], new byte[8], BitConverter.GetBytes(8419055756211858106).Reverse());",
          "+//            var test3 = BitConverter.GetBytes(G_n(0, 0, BitConverter.ToUInt64(new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7}.Reverse().ToArray(), 0), LArr, SBox, Tau, C)).Reverse().ToArray();",
          "+//            var test31 = mora.G_n(new byte[8], new byte[8], new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7});",
          "+",
          "+//            844909074791976",
          "+//            10270856436754831767 : 6920",
          "+//            2087758179587162062 : 2392",
          "+//            1974221557608115638 : 8419055756211858106",
          "+//            1974221557608115638 : 8419055756211858106",
          "+",
          "+//h0",
          "+//            1366367376498725",
          "+//            12214781975665660759 : 4492",
          "+//            1352692565877422794 : 5209",
          "+//            15099911268225057261 : 12827465560520173572",
          "+//            15099911268225057261 : 12827465560520173572",
          "+",
          "+//h1",
          "+//            3039673566387514",
          "+//            6490368572603814171 : 2282",
          "+//            15057135322267701395 : 7363",
          "+//            13787692588855149020 : 3806373757163530076",
          "+//            13787692588855149020 : 3806373757163530076",
          "+",
          "+            var lst = new List<List<ulong>>();",
          "+            List<ulong[]> solutions = new List<ulong[]>();",
          "+",
          "+            var h = 0UL;",
          "+            for (int i = 0; i < t; i++)",
          "             {",
          "-                byte[] buffer = new byte[arraySize];",
          "-                _rng.GetBytes(buffer);",
          "-                yield return buffer;",
          "+                var r = MagicPoints(h, LArr, SBox, Tau, C);",
          "+                Console.WriteLine($\"{r.Item1} : {r.Item2}\");",
          "+                h = G_n(0, h, r.Item1, LArr, SBox, Tau, C);",
          "+                lst.Add(new List<ulong>() {r.Item1, r.Item2});",
          "             }",
          "-           ",
          "+",
          "+            ulong[] solution = new ulong[lst.Count];",
          "+            Solve(lst, solutions, solution);",
          "+",
          "+            return (solutions, h);",
          "         }",
          "         ",
          "-        private IEnumerable<byte> GetRandomByteArray2(int arraySize)",
          "+        private static void Solve(List<List<ulong>> list, List<ulong[]> solutions, ulong[] solution)",
          "         {",
          "-            byte[] buffer = new byte[arraySize];",
          "-            _rng.GetBytes(buffer);",
          "-            return buffer;",
          "+            if (solution.All(i => i != 0) && !solutions.Any(s => s.SequenceEqual(solution)))",
          "+                solutions.Add(solution);",
          "+            for (int i = 0; i < list.Count; i++)",
          "+            {",
          "+                if (solution[i] != 0)",
          "+                    continue; // a caller up the hierarchy set this index to be a number",
          "+                for (int j = 0; j < list[i].Count; j++)",
          "+                {",
          "+                    if (solution.Contains(list[i][j]))",
          "+                        continue;",
          "+                    var solutionCopy = solution.ToArray();",
          "+                    solutionCopy[i] = list[i][j];",
          "+                    Solve(list, solutions, solutionCopy);",
          "+                }",
          "+            }",
          "         }",
          "-        ",
          "-        private IEnumerable<byte> GetRandomByteArray3(int arraySize)",
          "+",
          "+        private IEnumerable<byte> GetRandomByteArray(int arraySize)",
          "         {",
          "-            deviceptr<byte> buf = new deviceptr<byte>();",
          "             byte[] buffer = new byte[arraySize];",
          "             _rng.GetBytes(buffer);",
          "             return buffer;",
          "         }",
          "+",
          "     }",
          " }",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Options.cs b/Solution/Algorithm/Options.cs",
          "index 958c23f..d5169a0 100644",
          "--- a/Solution/Algorithm/Options.cs",
          "+++ b/Solution/Algorithm/Options.cs",
          "@@ -4,11 +4,16 @@ namespace Algorithm",
          " {",
          "     public class Options",
          "     {",
          "-        [Option('i', \"input\", Required = true, Default = \"\",",
          "+        [Option('t', \"t\", Required = false, Default = 5,",
          "             HelpText =",
          "-                \"Input data file path\")]",
          "-        public string InputFile { get; set; }",
          "+                \"Operations count (2^t messages)\")]",
          "+        public int T { get; set; }",
          "         ",
          "+//        [Option('i', \"input\", Required = true, Default = \"\",",
          "+//            HelpText =",
          "+//                \"Input data file path\")]",
          "+//        public string InputFile { get; set; }",
          "+//        ",
          "         [Option('o', \"output\", Required = true, Default = \"\",",
          "             HelpText =",
          "                 \"Output data file path\")]",
          "diff --git a/Solution/Algorithm/ParallelForDelegateTest.cs b/Solution/Algorithm/ParallelForDelegateTest.cs",
          "deleted file mode 100644",
          "index 53facfd..0000000",
          "--- a/Solution/Algorithm/ParallelForDelegateTest.cs",
          "+++ /dev/null",
          "@@ -1,95 +0,0 @@",
          "-\ufeffusing System;",
          "-using System.Linq;",
          "-using Alea;",
          "-using Alea.Parallel;",
          "-using NUnit.Framework;",
          "-",
          "-namespace Algorithm",
          "-{",
          "-    class ParallelForDelegateTest",
          "-    {",
          "-        private const int Length = 1000000;",
          "-",
          "-        [GpuManaged]",
          "-        public static void Transform<T>(Func<T, T, T> op, T[] result, T[] arg1, T[] arg2)",
          "-        {",
          "-            Action<int> action = i => result[i] = op(arg1[i], arg2[i]);",
          "-",
          "-            Gpu.Default.For(0, result.Length, action);",
          "-        }",
          "-",
          "-        private static T ConvertValue<T, TU>(TU value) where TU : IConvertible",
          "-        {",
          "-            return (T)Convert.ChangeType(value, typeof(T));",
          "-        }",
          "-",
          "-        [Test]",
          "-        [GpuManaged]",
          "-        public static void AddDouble()",
          "-        {",
          "-            var arg1 = Enumerable.Range(0, Length).Select(ConvertValue<double, int>).ToArray();",
          "-            var arg2 = Enumerable.Range(0, Length).Select(ConvertValue<double, int>).ToArray();",
          "-            var result = new double[Length];",
          "-",
          "-            Transform((x, y) => x + y, result, arg1, arg2);",
          "-",
          "-            var expected = arg1.Zip(arg2, (x, y) => x + y);",
          "-",
          "-            Assert.That(result, Is.EqualTo(expected));",
          "-        }",
          "-",
          "-        private struct Complex<T>",
          "-        {",
          "-            public T Real;",
          "-            public T Imag;",
          "-",
          "-            public override string ToString()",
          "-            {",
          "-                return $\"({Real}+I{Imag})\";",
          "-            }",
          "-        }",
          "-",
          "-        private static MagicInput Test(MagicInput a, int[] b)",
          "-        {",
          "-            var t = a.X;",
          "-            while (t >> 56 != 0)",
          "-            {",
          "-                t = t >> 10;",
          "-            }",
          "-            return new MagicInput {X = a.X};",
          "-        }",
          "-",
          "-        [GpuManaged, Test]",
          "-        public static void AddComplexDouble()",
          "-        {",
          "-            var rng = new Random();",
          "-            var arg1 = Enumerable.Range(0, Length).Select(i => new MagicInput { X = (ulong)rng.Next(), X0 = (ulong)rng.Next() }).ToArray();",
          "-            var arg2 = Enumerable.Range(0, Length).Select(i =>  new MagicInput { X = (ulong)rng.Next(), X0 = (ulong)rng.Next() }).ToArray();",
          "-            var result = new MagicInput[Length];",
          "-",
          "-            Func<MagicInput, MagicInput, MagicInput> complexAdd = (x, y) =>",
          "-            {",
          "-                var t = x.X;",
          "-                while (t >> 56 != 0)",
          "-                {",
          "-                    if (t != 0)",
          "-                    {",
          "-                        return new MagicInput {X = x.X};",
          "-                    }",
          "-                }",
          "-                return new MagicInput {X = x.X};",
          "-            };",
          "-",
          "-            var s = new int[16];",
          "-            ",
          "-            Gpu.Default.For(0, result.Length, i => { result[i] = Test(arg1[i], s); });",
          "-            ",
          "-//           Transform(complexAdd, result, arg1, arg2);",
          "-",
          "-            var expected = arg1.Zip(arg2, complexAdd);",
          "-",
          "-            Assert.That(result, Is.EqualTo(expected));",
          "-        }     ",
          "-    }",
          "-",
          "-}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Program.cs b/Solution/Algorithm/Program.cs",
          "index 00e0c0f..7d410d5 100644",
          "--- a/Solution/Algorithm/Program.cs",
          "+++ b/Solution/Algorithm/Program.cs",
          "@@ -1,149 +1,56 @@",
          " \ufeffusing System;",
          "-using System.Collections;",
          " using System.Collections.Generic;",
          "-using System.ComponentModel;",
          " using System.IO;",
          " using System.Linq;",
          "-using Alea;",
          "-using Alea.Parallel;",
          " using CommandLine;",
          "-using CommandLine.Text;",
          " using MoraHash;",
          " using MoreLinq;",
          "-using MoreLinq.Extensions;",
          "-using ServiceStack.Logging;",
          " ",
          " namespace Algorithm",
          " {",
          "     class Program",
          "     {",
          "-       static void Main(string[] args)",
          "+        static void Main(string[] args)",
          "         {",
          "-            var arg1 = Enumerable.Range(0, 10000).ToArray();",
          "-            var arg2 = Enumerable.Range(0, 10000).ToArray();",
          "-            var result = new int[10000];",
          "-",
          "-//            L3(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "-",
          "-            var mora = new HashFunction();",
          "-            var m = new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "-//            var bytes = new byte[] {14, 7, 9, 12, 9, 5, 14, 12, 15, 11, 11, 12, 10, 8, 3, 12};",
          "-//            var bytes2 = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7};",
          "-//            var bytes3 = Enumerable.Repeat((byte) 0xF, 16).ToArray();",
          "-//            ",
          "-//            var old = L3(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "-//                ",
          "-//            old = bytes2.Xor(old);",
          "-//            old = S(old);",
          "-//            old = P(old);",
          "-//            old = L3(old);",
          "-//            ",
          "-//",
          "-//            var n = mora.S(new byte[8]);",
          "-//            n = mora.P(n);",
          "-//            n = mora.L(n);",
          "-",
          "-//            n = m.Xor(n);",
          "-//            n = mora.S(n);",
          "-//            n = mora.P(n);",
          "-//            n = mora.L(n);",
          "-",
          "-//            var h = mora.ComputeHash(m);",
          "-",
          "-//            var res = mora.L(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "-//",
          "-//            res = mora.L(mora.P(mora.S(bytes)));",
          "-",
          "-            var test = BitConverter.ToInt64(new byte[] {0xf9, 0xcb, 0xfe, 0xc9, 0xb6, 0x89, 0xab, 0x5b}.Xor(new byte[]",
          "-                {0x92, 0x5b, 0x4e, 0xf4, 0x9a, 0x5e, 0x71, 0x74}), 0);",
          "-",
          "-            var test2 = 0xf9cbfec9b689ab5b ^ 0x925b4ef49a5e7174;",
          "-            ",
          "-            var test3 = 0x6b90b03d2cd7da2f;",
          "-            var col = new Multicollision();",
          "-            col.FindCollisions();",
          "-            ",
          "-            ",
          "-//            var hash = new HashFunction();",
          "-////            var m = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf};",
          "-//            var m = new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "-//",
          "-//            hash.ComputeHash(m);",
          "-//            var h0 = new byte[16];",
          "-//            var N0 = new byte[16];",
          "-//            var K = N0.Xor(h0);",
          "-//            K = hash.S(K);",
          "-//            K = hash.P(K);",
          "-//            K = hash.L(K);",
          "-//",
          "-//            var m1 = m.Xor(K);",
          "-//            m1 = hash.S(m1);",
          "-//            m1 = hash.P(m1);",
          "-//            m1 = hash.L(m1.Reverse().ToArray());",
          "-//            ",
          "-//            ",
          "-//            int q = 0;",
          "-//            ",
          "-//            //            Console.WriteLine(HelpText.AutoBuild(result, _ => _, _ => _));",
          "-//",
          "-//            var input = Enumerable.Range(1, 0xFFFF).Select(num => new BitArray(BitConverter.GetBytes(num)).Cast<bool>().Reverse().ToArray()).Select(bits => bits.Skip(16).ToArray()).ToArray();",
          "-//            ",
          "-////            var output = new byte[] {0x2, 0xc, 0x5, 0xb}.ToArray();",
          "-////            var output2 = new byte[] {0x8, 0x3, 0x6, 0x2}.ToArray();",
          "-//            var output = new byte[] {0xf, 0xa, 0x4, 0xc, 0x0, 0xe, 0x2, 0xf, 0xb, 0x6, 0x3, 0xf, 0x3, 0xe, 0xc, 0xb};",
          "-//            var inp = new byte[] {0xb, 0x8, 0x1, 0xf, 0xc, 0xb, 0xc, 0x5, 0x5, 0xe, 0x9, 0x4, 0xf, 0x3, 0xc, 0xf};",
          "-//",
          "-//            var output2 = L3(inp);",
          "-//",
          "-//            var b = MoreEnumerable.Batch(output, 4).Select(o => input.FirstOrDefault(t => L(t).SequenceEqual(o)))",
          "-//                .Select(",
          "-//                    bits => MoreEnumerable.Batch(bits, 4).ToArray()",
          "-//                        .Select(c => MoreEnumerable.PadStart(c, 8).ToArray()).SelectMany(k => k).ToArray()",
          "-//                ).Select(bits => MoreEnumerable.Batch(bits, 8).Select(s => new BitArray(s.Reverse().ToArray())).ToArray())",
          "-//                .SelectMany(k => k).ToArray();",
          "-//",
          "-//            var res = new byte[16];",
          "-//            ",
          "-//            for (int i = 0; i < b.Length; i++)",
          "-//            {",
          "-//                b[i].CopyTo(res, i); ",
          "-//            }",
          "-//",
          "-//            ",
          "-//            var output2_2 = L2(res);",
          "-//",
          "-//            int a = 0;",
          "-            ",
          "+            var result = Parser.Default.ParseArguments<Options>(args);",
          "             ",
          "-//            var result = Parser.Default.ParseArguments<Options>(args);",
          "-//            ",
          "-//            var errors = new List<CommandLine.Error>();",
          "-//            var parserResults = result",
          "-//                    .WithNotParsed(x => errors = x.ToList())",
          "-//                ;",
          "-//",
          "-//            if (errors.Any())",
          "-//            {",
          "-//                errors.ForEach(x => Console.WriteLine(x.ToString()));",
          "-//                return;",
          "-//            }",
          "-//",
          "-//            if (result.Errors.Any())",
          "-//            {",
          "-//                throw new ArgumentException();",
          "-//            }",
          "-//",
          "+            var errors = new List<CommandLine.Error>();",
          "+            var parserResults = result",
          "+                    .WithNotParsed(x => errors = x.ToList())",
          "+                ;",
          "+",
          "+            if (errors.Any())",
          "+            {",
          "+                errors.ForEach(x => Console.WriteLine(x.ToString()));",
          "+                return;",
          "+            }",
          "+",
          "+            if (result.Errors.Any())",
          "+            {",
          "+                throw new ArgumentException();",
          "+            }",
          "+",
          " //            if (!File.Exists(result.Value.OutputFile))",
          " //            {",
          " //                throw new FileNotFoundException(result.Value.OutputFile);",
          " //            }",
          " //            ",
          " //            var hash = new HashFunction();",
          "-//",
          "+",
          " //            var resultHash = hash.ComputeHash(File.ReadAllBytes(result.Value.OutputFile));",
          "-//            ",
          "-//            File.WriteAllText(result.Value.OutputFile, resultHash);",
          "-            ",
          "+",
          "+            var collisions = new Multicollision();",
          "+            var messages = collisions.FindCollisions(result.Value.T);",
          "+",
          "+            using (var sw = File.CreateText(result.Value.OutputFile))",
          "+            {",
          "+                sw.WriteLine($\"h = {BitConverter.ToString(BitConverter.GetBytes(messages.Item2).Reverse().ToArray()).Replace(\"-\", string.Empty)}\");",
          "+                messages.Item1.Select(msg => msg.SelectMany(m => BitConverter.GetBytes(m).Reverse())).ForEach(msg =>",
          "+                {",
          "+                    sw.WriteLine(HashFunction.StringRepresentation(msg.ToArray()));",
          "+                });  ",
          "+            }",
          "+",
          "             Console.ReadLine();",
          "         }",
          "     }",
          "diff --git a/Solution/MoraHash.Tests/MoraHash.Tests.csproj b/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "index bf2f330..c70862c 100644",
          "--- a/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "+++ b/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "@@ -1,20 +1,76 @@",
          "-\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "-",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",
          "+  <Import Project=\"..\\packages\\NUnit.3.12.0\\build\\NUnit.props\" Condition=\"Exists('..\\packages\\NUnit.3.12.0\\build\\NUnit.props')\" />",
          "+  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />",
          "+  <PropertyGroup>",
          "+    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>",
          "+    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>",
          "+    <ProjectGuid>{D2DBA511-F215-439F-8733-E12D0808A7A3}</ProjectGuid>",
          "+    <OutputType>Library</OutputType>",
          "+    <AppDesignerFolder>Properties</AppDesignerFolder>",
          "+    <RootNamespace>MoraHash.Tests</RootNamespace>",
          "+    <AssemblyName>MoraHash.Tests</AssemblyName>",
          "+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>",
          "+    <FileAlignment>512</FileAlignment>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugSymbols>true</DebugSymbols>",
          "+    <DebugType>full</DebugType>",
          "+    <Optimize>false</Optimize>",
          "+    <OutputPath>bin\\Debug\\</OutputPath>",
          "+    <DefineConstants>DEBUG;TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugType>pdbonly</DebugType>",
          "+    <Optimize>true</Optimize>",
          "+    <OutputPath>bin\\Release\\</OutputPath>",
          "+    <DefineConstants>TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <ItemGroup>",
          "+    <Reference Include=\"nunit.framework, Version=3.12.0.0, Culture=neutral, PublicKeyToken=2638cd05610744eb\">",
          "+      <HintPath>..\\packages\\NUnit.3.12.0\\lib\\net45\\nunit.framework.dll</HintPath>",
          "+      <Private>True</Private>",
          "+    </Reference>",
          "+    <Reference Include=\"System\" />",
          "+    <Reference Include=\"System.Core\" />",
          "+    <Reference Include=\"System.Data\" />",
          "+    <Reference Include=\"System.Xml\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <Compile Include=\"TestMoraHash.cs\" />",
          "+    <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <None Include=\"packages.config\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <ProjectReference Include=\"..\\Algorithm\\Algorithm.csproj\">",
          "+      <Project>{98508736-247b-41bb-9221-70c900431b19}</Project>",
          "+      <Name>Algorithm</Name>",
          "+    </ProjectReference>",
          "+    <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\">",
          "+      <Project>{8a69aa3f-5fea-451b-9efe-528b68bc478c}</Project>",
          "+      <Name>MoraHash</Name>",
          "+    </ProjectReference>",
          "+  </ItemGroup>",
          "+  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />",
          "+  <Target Name=\"EnsureNuGetPackageBuildImports\" BeforeTargets=\"PrepareForBuild\">",
          "     <PropertyGroup>",
          "-        <TargetFramework>net472</TargetFramework>",
          "-        <Configurations>Debug;Release</Configurations>",
          "-        <Platforms>AnyCPU;x64</Platforms>",
          "+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105.The missing file is {0}.</ErrorText>",
          "     </PropertyGroup>",
          "-",
          "-    <ItemGroup>",
          "-      <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.8.0\" />",
          "-      <PackageReference Include=\"MSTest.TestAdapter\" Version=\"2.1.2\" />",
          "-      <PackageReference Include=\"xunit\" Version=\"2.4.1\" />",
          "-      <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.3\" />",
          "-    </ItemGroup>",
          "-",
          "-    <ItemGroup>",
          "-      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />",
          "-    </ItemGroup>",
          "-",
          "-</Project>",
          "+    <Error Condition=\"!Exists('..\\packages\\NUnit.3.12.0\\build\\NUnit.props')\" Text=\"$([System.String]::Format('$(ErrorText)', '..\\packages\\NUnit.3.12.0\\build\\NUnit.props'))\" />",
          "+  </Target>",
          "+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ",
          "+         Other similar extension points exist, see Microsoft.Common.targets.",
          "+    <Target Name=\"BeforeBuild\">",
          "+    </Target>",
          "+    <Target Name=\"AfterBuild\">",
          "+    </Target>",
          "+    -->",
          "+</Project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash.Tests/Properties/AssemblyInfo.cs b/Solution/MoraHash.Tests/Properties/AssemblyInfo.cs",
          "new file mode 100644",
          "index 0000000..a7fa963",
          "--- /dev/null",
          "+++ b/Solution/MoraHash.Tests/Properties/AssemblyInfo.cs",
          "@@ -0,0 +1,35 @@",
          "+\ufeffusing System.Reflection;",
          "+using System.Runtime.InteropServices;",
          "+",
          "+// General Information about an assembly is controlled through the following ",
          "+// set of attributes. Change these attribute values to modify the information",
          "+// associated with an assembly.",
          "+[assembly: AssemblyTitle(\"MoraHash.Tests\")]",
          "+[assembly: AssemblyDescription(\"\")]",
          "+[assembly: AssemblyConfiguration(\"\")]",
          "+[assembly: AssemblyCompany(\"\")]",
          "+[assembly: AssemblyProduct(\"MoraHash.Tests\")]",
          "+[assembly: AssemblyCopyright(\"Copyright \u00a9  2020\")]",
          "+[assembly: AssemblyTrademark(\"\")]",
          "+[assembly: AssemblyCulture(\"\")]",
          "+",
          "+// Setting ComVisible to false makes the types in this assembly not visible ",
          "+// to COM components.  If you need to access a type in this assembly from ",
          "+// COM, set the ComVisible attribute to true on that type.",
          "+[assembly: ComVisible(false)]",
          "+",
          "+// The following GUID is for the ID of the typelib if this project is exposed to COM",
          "+[assembly: Guid(\"D2DBA511-F215-439F-8733-E12D0808A7A3\")]",
          "+",
          "+// Version information for an assembly consists of the following four values:",
          "+//",
          "+//      Major Version",
          "+//      Minor Version ",
          "+//      Build Number",
          "+//      Revision",
          "+//",
          "+// You can specify all the values or you can default the Build and Revision Numbers ",
          "+// by using the '*' as shown below:",
          "+// [assembly: AssemblyVersion(\"1.0.*\")]",
          "+[assembly: AssemblyVersion(\"1.0.0.0\")]",
          "+[assembly: AssemblyFileVersion(\"1.0.0.0\")]",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash.Tests/TestHash.cs b/Solution/MoraHash.Tests/TestHash.cs",
          "deleted file mode 100644",
          "index 36f1907..0000000",
          "--- a/Solution/MoraHash.Tests/TestHash.cs",
          "+++ /dev/null",
          "@@ -1,26 +0,0 @@",
          "-\ufeffusing System;",
          "-using Xunit;",
          "-",
          "-namespace MoraHash.Tests",
          "-{",
          "-    public class TestHash : IDisposable",
          "-    {",
          "-        [Fact]",
          "-        public void Test()",
          "-        {",
          "-            var hash = new HashFunction();",
          "-            var m = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7};",
          "-            ",
          "-            var res = hash.ComputeHash(m);",
          "-            ",
          "-            Assert.NotNull(res);",
          "-            Assert.NotEmpty(res);",
          "-        }",
          "-",
          "-",
          "-",
          "-        public void Dispose()",
          "-        {",
          "-        }",
          "-    }",
          "-}",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash.Tests/TestMoraHash.cs b/Solution/MoraHash.Tests/TestMoraHash.cs",
          "new file mode 100644",
          "index 0000000..76d8d45",
          "--- /dev/null",
          "+++ b/Solution/MoraHash.Tests/TestMoraHash.cs",
          "@@ -0,0 +1,41 @@",
          "+\ufeffusing System;",
          "+using System.Linq;",
          "+using Algorithm;",
          "+using NUnit.Framework;",
          "+",
          "+namespace MoraHash.Tests",
          "+{",
          "+    public class TestMoraHash",
          "+    {",
          "+        [Test]",
          "+        public void TestG_n()",
          "+        {",
          "+            // h1 \u0438\u0437 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0430",
          "+            var expected = new byte[] {0x1c, 0x9b, 0xea, 0x78, 0xab, 0x26, 0x32, 0x56};",
          "+            // \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0430",
          "+            var m = new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "+            var mora = new HashFunction();",
          "+            ",
          "+            var result = mora.G_n(new byte[8], new byte[8], m);",
          "+            var resultMultiCol = Multicollision.G_n(0, 0, BitConverter.ToUInt64(m.Reverse().ToArray(), 0), Constants.L,",
          "+                Constants.SBox, Constants.Tau, Constants.C);",
          "+            ",
          "+            Assert.True(expected.SequenceEqual(result));",
          "+            Assert.True(expected.SequenceEqual(BitConverter.GetBytes(resultMultiCol).Reverse()));",
          "+        }",
          "+        ",
          "+        ",
          "+        [Test]",
          "+        public void TestHash()",
          "+        {",
          "+            //h \u0438\u0437 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0430",
          "+            var expected = new byte[] {0xb1, 0x7e, 0xb3, 0xf6, 0x0f, 0x29, 0x0e, 0xfd};",
          "+            // \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0430",
          "+            var m = new byte[] { 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "+            var mora = new HashFunction();",
          "+            var result = mora.ComputeHash(m);",
          "+            ",
          "+            Assert.True(expected.SequenceEqual(result));",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash.Tests/packages.config b/Solution/MoraHash.Tests/packages.config",
          "new file mode 100644",
          "index 0000000..4157381",
          "--- /dev/null",
          "+++ b/Solution/MoraHash.Tests/packages.config",
          "@@ -0,0 +1,4 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<packages>",
          "+  <package id=\"NUnit\" version=\"3.12.0\" targetFramework=\"net472\" />",
          "+</packages>",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash/ByteUtils.cs b/Solution/MoraHash/ByteUtils.cs",
          "index c366313..753369e 100644",
          "--- a/Solution/MoraHash/ByteUtils.cs",
          "+++ b/Solution/MoraHash/ByteUtils.cs",
          "@@ -13,6 +13,22 @@ namespace MoraHash",
          "         public static byte[] RingSum(this IEnumerable<byte> a, IEnumerable<byte> b, int dim = 16) => a.Zip(b.Pad(a.Count()), (b1, b2) => (b1, b2))",
          "             .Select(tup => (byte) ((uint) (tup.b1 + tup.b2) % dim)).ToArray();",
          "         ",
          "+        public static byte[] AddModulo64(this byte[] a, byte[] b)",
          "+        {",
          "+            byte[] temp = new byte[8];",
          "+            int i = 0, t = 0;",
          "+            byte[] tempA = new byte[8];",
          "+            byte[] tempB = new byte[8];",
          "+            Array.Copy(a, 0, tempA, 8 - a.Length, a.Length);",
          "+            Array.Copy(b, 0, tempB, 8 - b.Length, b.Length);",
          "+            for (i = 7; i >= 0; i--)",
          "+            {",
          "+                t = tempA[i] + tempB[i] + (t >> 8);",
          "+                temp[i] = (byte)(t & 0xFF);",
          "+            }",
          "+            return temp;",
          "+        }",
          "+        ",
          "         public static byte JoinBytes(byte hi, byte low) => (byte)((hi << 4) | (low & 0xffffffffL));",
          " ",
          "         public static (byte hi, byte low) SplitByte(byte val) => ((byte) (val >> 4), (byte) (val & 0xf));",
          "diff --git a/Solution/MoraHash/Constants.cs b/Solution/MoraHash/Constants.cs",
          "index bd3d68d..3da3739 100644",
          "--- a/Solution/MoraHash/Constants.cs",
          "+++ b/Solution/MoraHash/Constants.cs",
          "@@ -7,7 +7,7 @@",
          "             0xc0164633575a9699,",
          "             0x925b4ef49a5e7174,",
          "             0x86a89cdcf673be26,",
          "-            0x86a89cdcf673be26,",
          "+            0x1885558f0eaca3f1,",
          "             0xdcfc5b89e35e8439,",
          "             0x54b9edc789464d23,",
          "             0xf80d49afde044bf9,",
          "@@ -16,7 +16,7 @@",
          "         };",
          " ",
          "         // \u041d\u0435\u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u0431\u0438\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u044b\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432",
          "-        public static readonly byte[] SBox =",
          "+        public static readonly int[] SBox =",
          "         {",
          "             15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10",
          "         };",
          "@@ -34,14 +34,22 @@",
          " //            0x8, 0x5, 0x1, 0x1, 0x2, 0x4, 0x8, 0xc, 0xb, 0xd, 0x7, 0xb, 0x5, 0x6, 0xb, 0x1,",
          " //            0x4, 0xb, 0x9, 0x9, 0x1, 0x2, 0x4, 0x6, 0xc, 0xf, 0xa, 0xc, 0xb, 0x3, 0xc, 0x9,",
          " //            0x2, 0xc, 0xd, 0xd, 0x9, 0x1, 0x2, 0x3, 0x6, 0xe, 0x5, 0x6, 0xc, 0x8, 0x6, 0xd",
          "+//        };",
          "+        ",
          "+//        public static readonly int[] L =",
          "+//        {",
          "+//            0x3a22, 0x483b, 0x59e5, 0xac52,",
          "+//            0x8511, 0x248c, 0xbd7b, 0x56b1,",
          "+//            0x4b99, 0x1246, 0xcfac, 0xb3c9,",
          "+//            0x2cdd, 0x9123, 0x6e56 ,0xc86d",
          " //        };",
          "         ",
          "         public static readonly int[] L =",
          "         {",
          "-            0x3a22, 0x483b, 0x59e5, 0xac52,",
          "-            0x8511, 0x248c, 0xbd7b, 0x56b1,",
          "-            0x4b99, 0x1246, 0xcfac, 0xb3c9,",
          "-            0x2cdd, 0x9123, 0x6e56 ,0xc86d",
          "+            0x3a22, 0x8511, 0x4b99, 0x2cdd,",
          "+            0x483b, 0x248c, 0x1246, 0x9123,",
          "+            0x59e5, 0xbd7b, 0xcfac, 0x6e56,",
          "+            0xac52, 0x56b1, 0xb3c9, 0xc86d",
          "         };",
          "     }",
          " }",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash/HashFunction.cs b/Solution/MoraHash/HashFunction.cs",
          "index 546a23e..a9cdd47 100644",
          "--- a/Solution/MoraHash/HashFunction.cs",
          "+++ b/Solution/MoraHash/HashFunction.cs",
          "@@ -47,7 +47,7 @@ namespace MoraHash",
          "                 tmp[i * 2 + 1] = splitted.low;",
          "             }",
          "             ",
          "-            var res = Enumerable.Range(0, tmp.Length).Select(i => Constants.SBox[tmp[i]]).ToArray();",
          "+            var res = Enumerable.Range(0, tmp.Length).Select(i => (byte)Constants.SBox[tmp[i]]).ToArray();",
          "             ",
          "             for (int i = 0; i < ret.Length; i++)",
          "             {",
          "@@ -63,7 +63,7 @@ namespace MoraHash",
          " //            Parallel.For(0, 4, i =>",
          "             for (int i = 0; i < 4; i++)",
          "             {",
          "-                byte[] t = new byte[2];",
          "+                int t = 0;",
          "                 byte[] tempArray = new byte[2];",
          "                 Array.Copy(state, i * 2, tempArray, 0, 2);",
          "                 tempArray = tempArray.Reverse().ToArray();",
          "@@ -76,15 +76,10 @@ namespace MoraHash",
          "                 {",
          "                     if (tempBits[j])",
          "                     {",
          "-                        var toXor = BitConverter.GetBytes(Constants.L[j]).Take(2).Reverse().ToArray();",
          "-",
          "-                        for (int k = 0; k < t.Length; k++)",
          "-                        {",
          "-                            t[k] ^= toXor[k];",
          "-                        }",
          "+                        t ^= Constants.L[j];",
          "                     }",
          "                 }",
          "-                Array.Copy(t, 0, result, i * 2, 2);",
          "+                Array.Copy(BitConverter.GetBytes(t).Reverse().ToArray(), 2, result, i * 2, 2);",
          "             }",
          " ",
          "             return result;",
          "@@ -97,13 +92,13 @@ namespace MoraHash",
          " ",
          "             byte[] n0 = new byte[BlockSize];",
          " ",
          "-            IEnumerable<IEnumerable<byte>> blocks = MoreEnumerable.Batch(message, BlockSize);",
          "+            IEnumerable<IEnumerable<byte>> blocks = message.Batch(BlockSize).ToArray();",
          " ",
          "-            MoreEnumerable.ForEach(blocks.Where(block => block.Count() >= BlockSize), block =>",
          "+            blocks.Where(block => block.Count() >= BlockSize).Reverse().ForEach(block =>",
          "             {",
          "-                h = G_n(_n, h, block); ",
          "-                _n = _n.RingSum(BitConverter.GetBytes((long)64).Reverse());",
          "-                _sigma = _sigma.RingSum(block);",
          "+                h = G_n(_n, h, block);",
          "+                _n = _n.AddModulo64(BitConverter.GetBytes((long)64).Reverse().ToArray());",
          "+                _sigma = _sigma.AddModulo64(block.ToArray());",
          "             });",
          " ",
          "             var lastBlockSize = blocks.Last().Count();",
          "@@ -118,9 +113,9 @@ namespace MoraHash",
          "            ",
          "             var msgLen = BitConverter.GetBytes((long)(message.Length * 8)).Reverse();",
          " ",
          "-            _n = _n.RingSum(msgLen);",
          "+            _n = _n.AddModulo64(msgLen.ToArray());",
          " ",
          "-            _sigma = _sigma.RingSum(m);",
          "+            _sigma = _sigma.AddModulo64(m);",
          " ",
          "             h = G_n(n0, h, _n);",
          "             h = G_n(n0, h, _sigma);",
          "@@ -136,19 +131,24 @@ namespace MoraHash",
          "         public byte[] E(byte[] k, byte[] m)",
          "         {",
          "             byte[] state = k.Xor(m);",
          "-            for (int i = 0; i < Constants.C.Length; i++)",
          "+            for (int i = 0; i < Constants.C.Length - 1; i++)",
          "             {",
          "-                state = L(P(S(state))).Xor(KeySchedule(k, i));",
          "+                k = KeySchedule(k, i);",
          "+                state = L(P(S(state))).Xor(k);",
          "             }",
          "             return state;",
          "         }",
          " ",
          "-        private byte[] KeySchedule(byte[] k, int i) => L(P(S(k.Xor(BitConverter.GetBytes(Constants.C[i])))));",
          "+        private byte[] KeySchedule(byte[] k, int i) => L(P(S(k.Xor(BitConverter.GetBytes(Constants.C[i]).Reverse()))));",
          "         ",
          "-        public string ComputeHash(byte[] message)",
          "+        public byte[] ComputeHash(byte[] message)",
          "+        {",
          "+            return GetHash(message.ToArray());",
          "+        }",
          "+",
          "+        public static string StringRepresentation(byte[] input)",
          "         {",
          "-            byte[] res = GetHash(message.ToArray());",
          "-            return BitConverter.ToString(res.ToArray()).Replace(\"-\", string.Empty);",
          "+            return BitConverter.ToString(input.ToArray()).Replace(\"-\", string.Empty);",
          "         }",
          "         ",
          "     }",
          "diff --git a/Solution/Multicollisions.sln b/Solution/Multicollisions.sln",
          "index 581f3a8..2a2066b 100644",
          "--- a/Solution/Multicollisions.sln",
          "+++ b/Solution/Multicollisions.sln",
          "@@ -5,35 +5,42 @@ VisualStudioVersion = 16.0.29326.143",
          " MinimumVisualStudioVersion = 10.0.40219.1",
          " Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash\", \"MoraHash\\MoraHash.csproj\", \"{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}\"",
          " EndProject",
          "-Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{98508736-247B-41BB-9221-70C900431B19}\"",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash.Tests\", \"MoraHash.Tests\\MoraHash.Tests.csproj\", \"{D2DBA511-F215-439F-8733-E12D0808A7A3}\"",
          " EndProject",
          "-Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MoraHash.Tests\", \"MoraHash.Tests\\MoraHash.Tests.csproj\", \"{1B48366A-328B-49CA-86D4-C01BBD609468}\"",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{98508736-247B-41BB-9221-70C900431B19}\"",
          " EndProject",
          " Global",
          " \tGlobalSection(SolutionConfigurationPlatforms) = preSolution",
          " \t\tDebug|Any CPU = Debug|Any CPU",
          " \t\tDebug|x64 = Debug|x64",
          " \t\tRelease|Any CPU = Release|Any CPU",
          "+\t\tRelease|x64 = Release|x64",
          " \tEndGlobalSection",
          " \tGlobalSection(ProjectConfigurationPlatforms) = postSolution",
          " \t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          " \t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "-\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "-\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.Build.0 = Release|Any CPU",
          " \t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|x64.ActiveCfg = Debug|x64",
          " \t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|x64.Build.0 = Debug|x64",
          "-\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "-\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.Build.0 = Release|Any CPU",
          "-\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.ActiveCfg = Debug|x64",
          "-\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.Build.0 = Debug|x64",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|x64.ActiveCfg = Release|x64",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|x64.Build.0 = Release|x64",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Debug|x64.ActiveCfg = Debug|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Debug|x64.Build.0 = Debug|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Release|x64.ActiveCfg = Release|Any CPU",
          "+\t\t{D2DBA511-F215-439F-8733-E12D0808A7A3}.Release|x64.Build.0 = Release|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          " \t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|x64.ActiveCfg = Debug|x64",
          " \t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|x64.Build.0 = Debug|x64",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.Build.0 = Release|Any CPU",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|x64.ActiveCfg = Debug|x64",
          "-\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|x64.Build.0 = Debug|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|x64.ActiveCfg = Release|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|x64.Build.0 = Release|x64",
          " \tEndGlobalSection",
          " \tGlobalSection(SolutionProperties) = preSolution",
          " \t\tHideSolutionNode = FALSE",
          ""
        ],
        "d493e1913ede701e8c135e0e1a601ec45be6f0ea": [
          "commit d493e1913ede701e8c135e0e1a601ec45be6f0ea",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Fri Dec 25 19:40:10 2020 +0300",
          "",
          "    weavers file",
          "",
          "diff --git a/Solution/Algorithm/FodyWeavers.xml b/Solution/Algorithm/FodyWeavers.xml",
          "new file mode 100644",
          "index 0000000..061ef2a",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/FodyWeavers.xml",
          "@@ -0,0 +1,4 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<Weavers>",
          "+  <Alea />",
          "+</Weavers>",
          "\\ No newline at end of file",
          ""
        ],
        "58e22bf6d1240f4da35626972d57dbc0aefcd48c": [
          "commit 58e22bf6d1240f4da35626972d57dbc0aefcd48c",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Fri Dec 25 19:39:34 2020 +0300",
          "",
          "    some issues",
          "",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "index ce975ed..2eb515a 100644",
          "--- a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "@@ -1,33 +1,36 @@",
          " <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          " <project version=\"4\">",
          "   <component name=\"ContentModelStore\">",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.net.test.sdk\\16.8.0\\build\\netcoreapp2.1\" t=\"Include\">",
          "-      <e p=\"Microsoft.NET.Test.Sdk.Program.cs\" t=\"Include\" />",
          "-    </e>",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.testplatform.testhost\\16.8.0\\build\\netcoreapp2.1\\x64\\testhost.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.testplatform.testhost\\16.8.0\\build\\netcoreapp2.1\\x64\\testhost.exe\" t=\"Include\" />",
          "     <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll\" t=\"Include\" />",
          "     <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\netcoreapp1.0\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.reporters.netcoreapp10.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.utility.netcoreapp10.dll\" t=\"Include\" />",
          "-    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.visualstudio.dotnetcore.testadapter.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\ru\" t=\"Include\">",
          "+      <e p=\"Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.resources.dll\" t=\"Include\" />",
          "+      <e p=\"Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.resources.dll\" t=\"Include\" />",
          "+      <e p=\"Microsoft.VisualStudio.TestPlatform.TestFramework.resources.dll\" t=\"Include\" />",
          "+    </e>",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.abstractions.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.reporters.net452.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.utility.net452.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\net452\\xunit.runner.visualstudio.testadapter.dll\" t=\"Include\" />",
          "     <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\extResources\" t=\"IncludeRecursive\" />",
          "     <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\resharper-host\\local\\Transient\\ReSharperHost\\v192\\SolutionCaches\\_Multicollisions.-582165928.00\" t=\"ExcludeRecursive\" />",
          "     <e p=\"C:\\Users\\niktv\\RiderProjects\\Multicollisions\\Solution\" t=\"IncludeFlat\">",
          "       <e p=\"Algorithm\" t=\"IncludeRecursive\">",
          "         <e p=\"Algorithm.csproj\" t=\"IncludeRecursive\" />",
          "+        <e p=\"App.config\" t=\"Include\" />",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"FodyWeavers.xml\" t=\"Include\" />",
          "+        <e p=\"MagicInput.cs\" t=\"Include\" />",
          "         <e p=\"Multicollision.cs\" t=\"Include\" />",
          "-        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "-          <e p=\"Debug\" t=\"Include\">",
          "-            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "-              <e p=\"Algorithm.AssemblyInfo.cs\" t=\"Include\" />",
          "-            </e>",
          "-          </e>",
          "-        </e>",
          "+        <e p=\"NewFile1.txt\" t=\"Include\" />",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "         <e p=\"Options.cs\" t=\"Include\" />",
          "+        <e p=\"ParallelForDelegateTest.cs\" t=\"Include\" />",
          "         <e p=\"Program.cs\" t=\"Include\" />",
          "+        <e p=\"Properties\" t=\"Include\">",
          "+          <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "+        </e>",
          "       </e>",
          "       <e p=\"MoraHash\" t=\"IncludeRecursive\">",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "@@ -35,21 +38,20 @@",
          "         <e p=\"Constants.cs\" t=\"Include\" />",
          "         <e p=\"HashFunction.cs\" t=\"Include\" />",
          "         <e p=\"MoraHash.csproj\" t=\"IncludeRecursive\" />",
          "-        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "-          <e p=\"Debug\" t=\"Include\">",
          "-            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "-              <e p=\"MoraHash.AssemblyInfo.cs\" t=\"Include\" />",
          "-            </e>",
          "-          </e>",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"Properties\" t=\"Include\">",
          "+          <e p=\"AssemblyInfo.cs\" t=\"Include\" />",
          "         </e>",
          "       </e>",
          "       <e p=\"MoraHash.Tests\" t=\"IncludeRecursive\">",
          "         <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "         <e p=\"MoraHash.Tests.csproj\" t=\"IncludeRecursive\" />",
          "         <e p=\"obj\" t=\"ExcludeRecursive\">",
          "-          <e p=\"Debug\" t=\"Include\">",
          "-            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "-              <e p=\"MoraHash.Tests.AssemblyInfo.cs\" t=\"Include\" />",
          "+          <e p=\"x64\" t=\"Include\">",
          "+            <e p=\"Debug\" t=\"Include\">",
          "+              <e p=\"net472\" t=\"Include\">",
          "+                <e p=\"MoraHash.Tests.AssemblyInfo.cs\" t=\"Include\" />",
          "+              </e>",
          "             </e>",
          "           </e>",
          "         </e>",
          "diff --git a/Solution/Algorithm/Algorithm.csproj b/Solution/Algorithm/Algorithm.csproj",
          "index 9693d6e..d38c337 100644",
          "--- a/Solution/Algorithm/Algorithm.csproj",
          "+++ b/Solution/Algorithm/Algorithm.csproj",
          "@@ -1,17 +1,117 @@",
          "-\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "-",
          "-    <PropertyGroup>",
          "-        <OutputType>Exe</OutputType>",
          "-        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "-    </PropertyGroup>",
          "-",
          "-    <ItemGroup>",
          "-      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />",
          "-    </ItemGroup>",
          "-",
          "-    <ItemGroup>",
          "-      <PackageReference Include=\"CommandLineParser\" Version=\"2.9.0-preview1\" />",
          "-      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "-    </ItemGroup>",
          "-",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",
          "+  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />",
          "+  <PropertyGroup>",
          "+    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>",
          "+    <Platform Condition=\" '$(Platform)' == '' \">x64</Platform>",
          "+    <ProjectGuid>{98508736-247B-41BB-9221-70C900431B19}</ProjectGuid>",
          "+    <OutputType>Exe</OutputType>",
          "+    <AppDesignerFolder>Properties</AppDesignerFolder>",
          "+    <RootNamespace>Algorithm</RootNamespace>",
          "+    <AssemblyName>Algorithm</AssemblyName>",
          "+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>",
          "+    <FileAlignment>512</FileAlignment>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugSymbols>true</DebugSymbols>",
          "+    <DebugType>full</DebugType>",
          "+    <Optimize>false</Optimize>",
          "+    <OutputPath>bin\\Debug\\</OutputPath>",
          "+    <DefineConstants>DEBUG;TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugType>pdbonly</DebugType>",
          "+    <Optimize>true</Optimize>",
          "+    <OutputPath>bin\\Release\\</OutputPath>",
          "+    <DefineConstants>TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|x64' \">",
          "+    <OutputPath>bin\\x64\\Debug\\</OutputPath>",
          "+    <PlatformTarget>x64</PlatformTarget>",
          "+  </PropertyGroup>",
          "+  <ItemGroup>",
          "+    <!--    <Reference Include=\"Alea, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "+    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.dll</HintPath>-->",
          "+    <!--      <Private>True</Private>-->",
          "+    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "+    <!--    </Reference>-->",
          "+    <!--    <Reference Include=\"Alea.IL, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "+    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.IL.dll</HintPath>-->",
          "+    <!--      <Private>True</Private>-->",
          "+    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "+    <!--    </Reference>-->",
          "+    <!--    <Reference Include=\"Alea.Parallel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=ba52afc3c2e933d6\">-->",
          "+    <!--      <HintPath>..\\packages\\Alea.3.0.4\\lib\\net45\\Alea.Parallel.dll</HintPath>-->",
          "+    <!--      <Private>True</Private>-->",
          "+    <!--      <SpecificVersion>True</SpecificVersion>-->",
          "+    <!--    </Reference>-->",
          "+    <!--    <Reference Include=\"FSharp.Core, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\">-->",
          "+    <!--      <HintPath>..\\packages\\FSharp.Core.5.0.0\\lib\\netstandard2.0\\FSharp.Core.dll</HintPath>-->",
          "+    <!--      <Private>True</Private>-->",
          "+    <!--    </Reference>-->",
          "+    <Reference Include=\"System\" />",
          "+    <Reference Include=\"System.Core\" />",
          "+    <Reference Include=\"System.Data\" />",
          "+    <Reference Include=\"System.Xml\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <Compile Include=\"MagicInput.cs\" />",
          "+    <Compile Include=\"Multicollision.cs\" />",
          "+    <Compile Include=\"Options.cs\" />",
          "+    <Compile Include=\"ParallelForDelegateTest.cs\" />",
          "+    <Compile Include=\"Program.cs\" />",
          "+    <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <Content Include=\"FodyWeavers.xml\" />",
          "+    <Content Include=\"NewFile1.txt\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <None Include=\"App.config\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <PackageReference Include=\"Alea\" Version=\"3.0.4\" />",
          "+    <PackageReference Include=\"Alea.Fody\" Version=\"3.0.4\" />",
          "+    <PackageReference Include=\"CommandLineParser\" Version=\"2.9.0-preview1\" />",
          "+    <PackageReference Include=\"FSharp.Core\" Version=\"5.0.0\" />",
          "+    <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "+    <PackageReference Include=\"NUnit\" Version=\"3.12.0\" />",
          "+    <PackageReference Include=\"ServiceStack.Common\" Version=\"5.10.2\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />",
          "+  </ItemGroup>",
          "+  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />",
          "+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ",
          "+         Other similar extension points exist, see Microsoft.Common.targets.",
          "+    <Target Name=\"BeforeBuild\">",
          "+    </Target>",
          "+    <Target Name=\"AfterBuild\">",
          "+    </Target>",
          "+    -->",
          " </Project>",
          "+<!--<Project Sdk=\"Microsoft.NET.Sdk\">-->",
          "+<!--    <PropertyGroup>-->",
          "+<!--        <OutputType>Exe</OutputType>-->",
          "+<!--        <TargetFramework>net472</TargetFramework>-->",
          "+<!--    </PropertyGroup>-->",
          "+<!--    <ItemGroup>-->",
          "+<!--      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />-->",
          "+<!--    </ItemGroup>-->",
          "+<!--    <ItemGroup>-->",
          "+<!--      <PackageReference Include=\"Alea\" Version=\"3.0.4\" />-->",
          "+<!--      <PackageReference Include=\"Alea.Fody\" Version=\"3.0.4\">-->",
          "+<!--        <PrivateAssets>all</PrivateAssets>-->",
          "+<!--        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>-->",
          "+<!--      </PackageReference>-->",
          "+<!--      <PackageReference Include=\"CommandLineParser\" Version=\"2.9.0-preview1\" />-->",
          "+<!--      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />-->",
          "+<!--      <PackageReference Include=\"ServiceStack.Common\" Version=\"5.10.2\" />-->",
          "+<!--    </ItemGroup>-->",
          "+<!--</Project>-->",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/App.config b/Solution/Algorithm/App.config",
          "new file mode 100644",
          "index 0000000..dad07ac",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/App.config",
          "@@ -0,0 +1,20 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+",
          "+<configuration>",
          "+    <configSections>",
          "+        <section name=\"aleaSettings\" type=\"Alea.Settings, Alea\"/>",
          "+    </configSections>",
          "+    <aleaSettings>",
          "+        <memory allowNonBlittableMemoryTransfer=\"true\"/>",
          "+        <resource path=\"@base\" assemblyPath=\"@base\"/>",
          "+        <cuBLAS version=\"8.0\"/>",
          "+        <cuRAND version=\"8.0\"/>",
          "+    </aleaSettings>",
          "+    <startup>",
          "+        <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.7.2\" />",
          "+    </startup>",
          "+    ",
          "+    <appSettings>",
          "+        ",
          "+    </appSettings>",
          "+</configuration>",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/MagicInput.cs b/Solution/Algorithm/MagicInput.cs",
          "new file mode 100644",
          "index 0000000..96ddcdb",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/MagicInput.cs",
          "@@ -0,0 +1,9 @@",
          "+\ufeffnamespace Algorithm",
          "+{",
          "+    public struct MagicInput",
          "+    {",
          "+        public ulong X;",
          "+        public ulong X0;",
          "+        public long Counter;",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Multicollision.cs b/Solution/Algorithm/Multicollision.cs",
          "index 0d83ad5..d55dc43 100644",
          "--- a/Solution/Algorithm/Multicollision.cs",
          "+++ b/Solution/Algorithm/Multicollision.cs",
          "@@ -1,10 +1,462 @@",
          "-\ufeffnamespace Algorithm",
          "+\ufeffusing System;",
          "+using System.Collections;",
          "+using System.Collections.Concurrent;",
          "+using System.Collections.Generic;",
          "+using System.Diagnostics;",
          "+using System.Linq;",
          "+using System.Reflection;",
          "+using System.Security.Cryptography;",
          "+using System.Security.Cryptography.X509Certificates;",
          "+using System.Text;",
          "+using System.Threading;",
          "+using System.Threading.Tasks;",
          "+using Alea;",
          "+using Alea.CSharp;",
          "+using Alea.cuRAND;",
          "+using Alea.Parallel;",
          "+using Microsoft.VisualBasic;",
          "+using MoraHash;",
          "+using MoreLinq;",
          "+using MoreLinq.Extensions;",
          "+using ServiceStack;",
          "+using ServiceStack.Logging;",
          "+",
          "+namespace Algorithm",
          " {",
          "     public class Multicollision",
          "     {",
          "+        private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();",
          "+",
          "+        private async Task<ulong> AsyncG_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            return await Task.Run(() => G_n(N, h, m, l, sBox, tau, c));",
          "+        }",
          "+        ",
          "+        private MagicInput GetMagic(MagicInput input, ulong h, int[] l, int[] sBox, int[] tau, ulong[] c, int size)",
          "+        {",
          "+            var x0 = input.X0;",
          "+            var x = G_n(0, h, x0, l, sBox, tau, c);",
          "+            long counter = 0;",
          "+",
          "+            //if first 16 bits are zero, x - magic num",
          "+            while (x >> (32 + size) != 0)",
          "+            {",
          "+                x = G_n(0, h, x, l, sBox, tau, c);",
          "+                counter++;",
          "+            }",
          "+            return new MagicInput() {X = x, X0 = x0, Counter = counter};",
          "+        }",
          "+",
          "+        [GpuManaged]",
          "+        private MagicInput[] Cycle(ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var size = 100_000;",
          "+            var t = (int)Math.Log(size, 2);",
          "+            var input = new ulong[size].AsParallel().Select(data => BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0)).Select(data => new MagicInput() {X0 = data}).ToArray();",
          "+            var result = new MagicInput[size];",
          "+",
          "+//            Gpu.Default.For(0, size, i =>",
          "+//            {",
          "+//                result[i] = GetMagic(input[i], l, sBox, tau, c);",
          "+//            });",
          "+//            new Thread(() =>",
          "+//            {",
          "+                            Gpu.Default.For(0, size, i =>",
          "+            {",
          "+                result[i] = GetMagic(input[i], h, l, sBox, tau, c, t);",
          "+            });",
          "+//                Parallel.For(0, size, (i) => { result[i] = GetMagic(input[i], l, sBox, tau, c, t); });",
          "+//            }).Start();",
          "+            ",
          "+",
          "+            return result;",
          "+        }",
          "+        ",
          "+//        [GpuManaged]",
          "+        private (ulong, ulong) MagicPoints(ulong h, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            Console.WriteLine(\"Begin\");",
          "+            (ulong, ulong) retVal = (0, 0);",
          "+            var dict = new ConcurrentDictionary<ulong, (ulong, long)>();",
          "+",
          "+            while (true)",
          "+            {",
          "+                var result = Cycle(h, l, sBox, tau, c);",
          "+//                var usedIndexes = new bool[result.Length];",
          "+//                while (!usedIndexes.All(i => i))",
          "+//                {",
          "+//                    var tmpResult = result.Where((res, i) =>",
          "+//                    {",
          "+//                        if (res.X == 0 && res.X0 == 0 || usedIndexes[i]) return false;",
          "+//",
          "+//                        usedIndexes[i] = true;",
          "+//                        return true;",
          "+//                    }).ToArray();",
          "+//",
          "+//                    if (!tmpResult.Any())",
          "+//                    {",
          "+//                        Thread.Sleep(5 * 60 * 1000);",
          "+//                        continue;",
          "+//                    }",
          "+//                    ",
          "+//                    Console.WriteLine($\"{usedIndexes.Count(i => i)}\");",
          "+",
          "+                    Parallel.ForEach(result, (res, state) =>",
          "+                    {",
          "+                        var x = res.X;",
          "+                        var x0 = res.X0;",
          "+                        var count = res.Counter;",
          "+",
          "+                        if (!dict.ContainsKey(x))",
          "+                        {",
          "+                            dict[x] = (x0, count);",
          "+                        }",
          "+                        else",
          "+                        {",
          "+                            var x1 = dict[x].Item1;",
          "+                            var count1 = dict[x].Item2;",
          "+",
          "+                            while (count1 > count)",
          "+                            {",
          "+                                x1 = G_n(0, h, x1, l, sBox, tau, c);",
          "+                                count1--;",
          "+                            }",
          "+",
          "+                            while (count > count1)",
          "+                            {",
          "+                                x0 = G_n(0, h, x0, l, sBox, tau, c);",
          "+                                count--;",
          "+                            }",
          "+",
          "+                            while (true)",
          "+                            {",
          "+                                var next = G_n(0, h, x1, l, sBox, tau, c);",
          "+                                var next2 = G_n(0, h, x0, l, sBox, tau, c);",
          "+                                ",
          "+                                if (next == next2) break;",
          "+",
          "+                                x1 = next;",
          "+                                x0 = next2;",
          "+                            }",
          "+",
          "+                            retVal.Item1 = x1;",
          "+                            retVal.Item2 = x0;",
          "+                            state.Break();",
          "+                        }",
          "+                    });",
          "+                ",
          "+                if (retVal != (0, 0)) break;",
          "+            }",
          "+",
          "+//            Console.WriteLine($\"{retVal.Item1} : {retVal.Item2}\");",
          "+            return retVal;",
          "+        }",
          "+        ",
          "+        private (ulong, ulong) Brent(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var power = 1;",
          "+            var lam = 1;",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+  ",
          "+            var tortoise = x0;",
          "+            var hare = G_n(0, 0, x0, l, sBox, tau, c);",
          "+",
          "+            while (tortoise != hare)",
          "+            {",
          "+                if (power == lam)",
          "+                {",
          "+                    tortoise = hare;",
          "+                    power *= 2;",
          "+                    lam = 0;",
          "+                }",
          "+                hare = G_n(0, 0, hare, l, sBox, tau, c);",
          "+                lam++;",
          "+            }",
          "+            ",
          "+            tortoise = hare = x0;",
          "+",
          "+            for (int i = 0; i < lam; i++)",
          "+            {",
          "+                hare = G_n(0, 0, hare, l, sBox, tau, c);",
          "+            }",
          "+",
          "+            while (true)",
          "+            {",
          "+                var nextTask = AsyncG_n(0, 0, tortoise, l, sBox, tau, c);",
          "+                var next2Task = AsyncG_n(0, 0, hare, l, sBox, tau, c);",
          "+                            ",
          "+                Task.WaitAll(nextTask, next2Task);",
          "+                            ",
          "+                if (nextTask.Result == next2Task.Result) break;",
          "+            ",
          "+                tortoise = nextTask.Result;",
          "+                hare = next2Task.Result;",
          "+            }",
          "+",
          "+            return (tortoise, hare);",
          "+        }",
          "+        ",
          "+        private (ulong, ulong) Floyd(int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var x0 = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+",
          "+            var hare = x0;",
          "+            var tortoise = x0;",
          "+",
          "+            while (true)",
          "+            {",
          "+                hare = G_n(0, 0, G_n(0, 0, hare, l, sBox, tau, c), l, sBox, tau, c);",
          "+                tortoise = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "+",
          "+//                Task.WaitAll(hareTask, tortoiseTask);",
          "+//                hare = hareTask.Result;",
          "+//                tortoise = tortoiseTask.Result;",
          "+                ",
          "+                if (hare == tortoise)",
          "+                {",
          "+                    break;",
          "+                }",
          "+            }",
          "+",
          "+            tortoise = x0;",
          "+",
          "+            while (true)",
          "+            {",
          "+                var nextTask = G_n(0, 0, tortoise, l, sBox, tau, c);",
          "+                var next2Task = G_n(0, 0, hare, l, sBox, tau, c);",
          "+                ",
          "+//                Task.WaitAll(nextTask, next2Task);",
          "+                ",
          "+                if (nextTask == next2Task) break;",
          "+            }",
          "+",
          "+            return (tortoise, hare);",
          "+        } ",
          "+",
          "+        private (ulong, ulong) Algo(int N, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            var size = 64 / N;",
          "+            var Y = new ulong[size];",
          "+            var u = new ulong[size];",
          "+            var v = new ulong[size];",
          "+            Y[0] = G_n(0, 0, BitConverter.ToUInt64(GetRandomByteArray2(8).ToArray(), 0), l, sBox, tau, c);",
          "+            var m = 0UL;",
          "+            var n = 0UL;",
          "+            var w = Y[0];",
          "+",
          "+            for (int i = 1; i <= size; i++)",
          "+            {",
          "+                for (int j = (i - 1) * N + 1; j <= i * N - 1; j++)",
          "+                {",
          "+                    Y[j] = G_n(0, 0, Y[j - 1], l, sBox, tau, c);",
          "+                    if (Y[j] < w)",
          "+                    {",
          "+                        w = Y[j];",
          "+                        n = (ulong)j;",
          "+                    } else if (Y[j] == w)",
          "+                    {",
          "+                        m = (ulong)j;",
          "+",
          "+                        return (m, n);",
          "+                    }",
          "+                }",
          "+",
          "+                for (int k = 1; k <= i - 1; k++)",
          "+                {",
          "+                    if (u[k] == w)",
          "+                    {",
          "+                        m = v[k];",
          "+                        return (m, n);",
          "+                    }",
          "+                }",
          "+",
          "+                u[i] = w;",
          "+                v[i] = n;",
          "+                w = G_n(0, 0, Y[i * N - 1], l, sBox, tau, c);",
          "+                n = (ulong)(i * N);",
          "+            }",
          "+",
          "+            return (0, 0);",
          "+        } ",
          "+        ",
          "+        private ulong GCD(ulong a, ulong b)",
          "+        {",
          "+            while (a != 0 && b != 0)",
          "+            {",
          "+                if (a > b)",
          "+                    a %= b;",
          "+                else",
          "+                    b %= a;",
          "+            }",
          "+",
          "+            return a | b;",
          "+        }",
          "+",
          "+        private int SplitLeftByte(ulong data, int byteNum)",
          "+        {",
          "+            int shift = (8 * byteNum);",
          "+            var b = (data >> shift) & 0xff;",
          "+            return (int)(b >> 4);",
          "+        }",
          "+        ",
          "+        private int SplitRightByte(ulong data, int byteNum)",
          "+        {",
          "+            int shift = (8 * byteNum);",
          "+            var b = (data >> shift) & 0xff;",
          "+            return (int)(b & 0xf);",
          "+        }",
          "+        ",
          "+        private ulong JoinBytes(int hi, int low)",
          "+        {",
          "+            return (ulong)((hi << 4) | (low & 0xffffffffL));",
          "+        }",
          "+",
          "+        public ulong P(ulong state, int[] tau)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (8 * i);",
          "+                var l = tau[i * 2] % 2 == 0 ? SplitLeftByte(state, tau[i * 2] / 2) : SplitRightByte(state, tau[i * 2] / 2);",
          "+                var r = tau[i * 2 + 1] % 2 == 0 ? SplitLeftByte(state, tau[i * 2 + 1] / 2) : SplitRightByte(state, tau[i * 2 + 1] / 2);",
          "+                ret |= JoinBytes(l, r) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        private ulong S(ulong state, int[] sBox)",
          "+        {",
          "+            ulong ret = 0;",
          "+            for (int i = 0; i < 8; i++)",
          "+            {",
          "+                int shift = (8 * i);",
          "+                ret |= JoinBytes(sBox[SplitLeftByte(state, i)], sBox[SplitRightByte(state, i)]) << shift;",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "+        ",
          "+        public ulong L(ulong state, int[] l)",
          "+        {",
          "+            ulong result = 0;",
          "+",
          "+            for (int i = 0; i < 4; i++)",
          "+            {",
          "+                int t = 0;",
          "+                var tmp = (int) ((state >> (i * 2 + 1 << 3)) & 0xFF) << (8 * i + 1 << 3) |",
          "+                          (int) ((state >> (i * 2 << 3)) & 0xFF);",
          "+                ",
          "+                for(int k = 0; k < 16; k++){",
          "+                    int mask =  1 << k;",
          "+                    int masked_n = tmp & mask;",
          "+                    int thebit = masked_n >> k;",
          "+",
          "+                    if (k < 8)",
          "+                    {",
          "+                        if (thebit == 1)",
          "+                            t ^= l[8 - k - 1];",
          "+                    }",
          "+                    else",
          "+                    {",
          "+                        if (thebit == 1)",
          "+                            t ^= l[24 - k - 1];",
          "+                    }",
          "+                }",
          "+",
          "+                var data = (ulong) t;",
          "+                result |= (data >> 8 | ((data & 0xFF) << 8)) << i * 16;",
          "+            }",
          "+",
          "+            return result;",
          "+        }",
          "+        ",
          "+        private ulong E(ulong k, ulong m, ulong[] c, int[] l, int[] sBox, int[] tau)",
          "+        {",
          "+            ulong state = k ^ m;",
          "+            for (int i = 0; i < c.Length; i++)",
          "+            {",
          "+                state = L(P(S(state, sBox), tau), l) ^ KeySchedule(k, c[i], l, sBox, tau);",
          "+            }",
          "+            return state;",
          "+        }",
          "+        ",
          "+        private ulong KeySchedule(ulong k, ulong c, int[] l, int[] sBox, int[] tau)",
          "+        {",
          "+            return L(P(S((k ^ c), sBox), tau), l);",
          "+        }",
          "+        ",
          "+        public ulong G_n(ulong N, ulong h, ulong m, int[] l, int[] sBox, int[] tau, ulong[] c)",
          "+        {",
          "+            return E(L(P(S(h ^ N, sBox), tau), l), m, c, l, sBox, tau) ^ h ^ m;",
          "+        }",
          "+        ",
          "+",
          "+",
          "+//        [GpuManaged]",
          "         public void FindCollisions()",
          "         {",
          "+            var mora = new HashFunction();",
          "             ",
          "+            ulong[] C =",
          "+            {",
          "+                0xc0164633575a9699,",
          "+                0x925b4ef49a5e7174,",
          "+                0x86a89cdcf673be26,",
          "+                0x86a89cdcf673be26,",
          "+                0xdcfc5b89e35e8439,",
          "+                0x54b9edc789464d23,",
          "+                0xf80d49afde044bf9,",
          "+                0x8cbbdf71ccaa43f1,",
          "+                0xcb43af722cb520b9",
          "+            };",
          "+            int[] Tau =",
          "+            {",
          "+                0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15",
          "+            };",
          "+            int[] LArr =",
          "+            {",
          "+                0x3a22, 0x483b, 0x59e5, 0xac52,",
          "+                0x8511, 0x248c, 0xbd7b, 0x56b1,",
          "+                0x4b99, 0x1246, 0xcfac, 0xb3c9,",
          "+                0x2cdd, 0x9123, 0x6e56 ,0xc86d",
          "+            };",
          "+            int[] SBox =",
          "+            {",
          "+                15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10",
          "+            };",
          "+",
          "+            var singleCollision = MagicPoints(12601850608120225315, LArr, SBox, Tau, C);",
          "+",
          "+            int a = 0;",
          "+",
          "+",
          "+        }",
          "+",
          "+        private IEnumerable<byte[]> GetRandomByteArray(int arraySize)",
          "+        {",
          "+            for (int i = 0; i < 10_000; i++)",
          "+            {",
          "+                byte[] buffer = new byte[arraySize];",
          "+                _rng.GetBytes(buffer);",
          "+                yield return buffer;",
          "+            }",
          "+           ",
          "+        }",
          "+        ",
          "+        private IEnumerable<byte> GetRandomByteArray2(int arraySize)",
          "+        {",
          "+            byte[] buffer = new byte[arraySize];",
          "+            _rng.GetBytes(buffer);",
          "+            return buffer;",
          "+        }",
          "+        ",
          "+        private IEnumerable<byte> GetRandomByteArray3(int arraySize)",
          "+        {",
          "+            deviceptr<byte> buf = new deviceptr<byte>();",
          "+            byte[] buffer = new byte[arraySize];",
          "+            _rng.GetBytes(buffer);",
          "+            return buffer;",
          "         }",
          "     }",
          " }",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/ParallelForDelegateTest.cs b/Solution/Algorithm/ParallelForDelegateTest.cs",
          "new file mode 100644",
          "index 0000000..53facfd",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/ParallelForDelegateTest.cs",
          "@@ -0,0 +1,95 @@",
          "+\ufeffusing System;",
          "+using System.Linq;",
          "+using Alea;",
          "+using Alea.Parallel;",
          "+using NUnit.Framework;",
          "+",
          "+namespace Algorithm",
          "+{",
          "+    class ParallelForDelegateTest",
          "+    {",
          "+        private const int Length = 1000000;",
          "+",
          "+        [GpuManaged]",
          "+        public static void Transform<T>(Func<T, T, T> op, T[] result, T[] arg1, T[] arg2)",
          "+        {",
          "+            Action<int> action = i => result[i] = op(arg1[i], arg2[i]);",
          "+",
          "+            Gpu.Default.For(0, result.Length, action);",
          "+        }",
          "+",
          "+        private static T ConvertValue<T, TU>(TU value) where TU : IConvertible",
          "+        {",
          "+            return (T)Convert.ChangeType(value, typeof(T));",
          "+        }",
          "+",
          "+        [Test]",
          "+        [GpuManaged]",
          "+        public static void AddDouble()",
          "+        {",
          "+            var arg1 = Enumerable.Range(0, Length).Select(ConvertValue<double, int>).ToArray();",
          "+            var arg2 = Enumerable.Range(0, Length).Select(ConvertValue<double, int>).ToArray();",
          "+            var result = new double[Length];",
          "+",
          "+            Transform((x, y) => x + y, result, arg1, arg2);",
          "+",
          "+            var expected = arg1.Zip(arg2, (x, y) => x + y);",
          "+",
          "+            Assert.That(result, Is.EqualTo(expected));",
          "+        }",
          "+",
          "+        private struct Complex<T>",
          "+        {",
          "+            public T Real;",
          "+            public T Imag;",
          "+",
          "+            public override string ToString()",
          "+            {",
          "+                return $\"({Real}+I{Imag})\";",
          "+            }",
          "+        }",
          "+",
          "+        private static MagicInput Test(MagicInput a, int[] b)",
          "+        {",
          "+            var t = a.X;",
          "+            while (t >> 56 != 0)",
          "+            {",
          "+                t = t >> 10;",
          "+            }",
          "+            return new MagicInput {X = a.X};",
          "+        }",
          "+",
          "+        [GpuManaged, Test]",
          "+        public static void AddComplexDouble()",
          "+        {",
          "+            var rng = new Random();",
          "+            var arg1 = Enumerable.Range(0, Length).Select(i => new MagicInput { X = (ulong)rng.Next(), X0 = (ulong)rng.Next() }).ToArray();",
          "+            var arg2 = Enumerable.Range(0, Length).Select(i =>  new MagicInput { X = (ulong)rng.Next(), X0 = (ulong)rng.Next() }).ToArray();",
          "+            var result = new MagicInput[Length];",
          "+",
          "+            Func<MagicInput, MagicInput, MagicInput> complexAdd = (x, y) =>",
          "+            {",
          "+                var t = x.X;",
          "+                while (t >> 56 != 0)",
          "+                {",
          "+                    if (t != 0)",
          "+                    {",
          "+                        return new MagicInput {X = x.X};",
          "+                    }",
          "+                }",
          "+                return new MagicInput {X = x.X};",
          "+            };",
          "+",
          "+            var s = new int[16];",
          "+            ",
          "+            Gpu.Default.For(0, result.Length, i => { result[i] = Test(arg1[i], s); });",
          "+            ",
          "+//           Transform(complexAdd, result, arg1, arg2);",
          "+",
          "+            var expected = arg1.Zip(arg2, complexAdd);",
          "+",
          "+            Assert.That(result, Is.EqualTo(expected));",
          "+        }     ",
          "+    }",
          "+",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Solution/Algorithm/Program.cs b/Solution/Algorithm/Program.cs",
          "index 1f3aa12..00e0c0f 100644",
          "--- a/Solution/Algorithm/Program.cs",
          "+++ b/Solution/Algorithm/Program.cs",
          "@@ -1,46 +1,148 @@",
          " \ufeffusing System;",
          "+using System.Collections;",
          " using System.Collections.Generic;",
          "+using System.ComponentModel;",
          " using System.IO;",
          " using System.Linq;",
          "+using Alea;",
          "+using Alea.Parallel;",
          " using CommandLine;",
          " using CommandLine.Text;",
          " using MoraHash;",
          "+using MoreLinq;",
          "+using MoreLinq.Extensions;",
          "+using ServiceStack.Logging;",
          " ",
          " namespace Algorithm",
          " {",
          "     class Program",
          "     {",
          "-        static void Main(string[] args)",
          "+       static void Main(string[] args)",
          "         {",
          "-            //            Console.WriteLine(HelpText.AutoBuild(result, _ => _, _ => _));",
          "-            var result = Parser.Default.ParseArguments<Options>(args);",
          "+            var arg1 = Enumerable.Range(0, 10000).ToArray();",
          "+            var arg2 = Enumerable.Range(0, 10000).ToArray();",
          "+            var result = new int[10000];",
          "+",
          "+//            L3(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "+",
          "+            var mora = new HashFunction();",
          "+            var m = new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "+//            var bytes = new byte[] {14, 7, 9, 12, 9, 5, 14, 12, 15, 11, 11, 12, 10, 8, 3, 12};",
          "+//            var bytes2 = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7};",
          "+//            var bytes3 = Enumerable.Repeat((byte) 0xF, 16).ToArray();",
          "+//            ",
          "+//            var old = L3(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "+//                ",
          "+//            old = bytes2.Xor(old);",
          "+//            old = S(old);",
          "+//            old = P(old);",
          "+//            old = L3(old);",
          "+//            ",
          "+//",
          "+//            var n = mora.S(new byte[8]);",
          "+//            n = mora.P(n);",
          "+//            n = mora.L(n);",
          "+",
          "+//            n = m.Xor(n);",
          "+//            n = mora.S(n);",
          "+//            n = mora.P(n);",
          "+//            n = mora.L(n);",
          "+",
          "+//            var h = mora.ComputeHash(m);",
          "+",
          "+//            var res = mora.L(Enumerable.Repeat((byte) 0xF, 16).ToArray());",
          "+//",
          "+//            res = mora.L(mora.P(mora.S(bytes)));",
          "+",
          "+            var test = BitConverter.ToInt64(new byte[] {0xf9, 0xcb, 0xfe, 0xc9, 0xb6, 0x89, 0xab, 0x5b}.Xor(new byte[]",
          "+                {0x92, 0x5b, 0x4e, 0xf4, 0x9a, 0x5e, 0x71, 0x74}), 0);",
          "+",
          "+            var test2 = 0xf9cbfec9b689ab5b ^ 0x925b4ef49a5e7174;",
          "             ",
          "-            var errors = new List<CommandLine.Error>();",
          "-            var parserResults = result",
          "-                    .WithNotParsed(x => errors = x.ToList())",
          "-                ;",
          "-",
          "-            if (errors.Any())",
          "-            {",
          "-                errors.ForEach(x => Console.WriteLine(x.ToString()));",
          "-                return;",
          "-            }",
          "-",
          "-            if (result.Errors.Any())",
          "-            {",
          "-                throw new ArgumentException();",
          "-            }",
          "-",
          "-            if (!File.Exists(result.Value.OutputFile))",
          "-            {",
          "-                throw new FileNotFoundException(result.Value.OutputFile);",
          "-            }",
          "+            var test3 = 0x6b90b03d2cd7da2f;",
          "+            var col = new Multicollision();",
          "+            col.FindCollisions();",
          "+            ",
          "+            ",
          "+//            var hash = new HashFunction();",
          "+////            var m = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf};",
          "+//            var m = new byte[] {0x01, 0xd4, 0x44, 0x90, 0x7e, 0xfb, 0x8c, 0xf7};",
          "+//",
          "+//            hash.ComputeHash(m);",
          "+//            var h0 = new byte[16];",
          "+//            var N0 = new byte[16];",
          "+//            var K = N0.Xor(h0);",
          "+//            K = hash.S(K);",
          "+//            K = hash.P(K);",
          "+//            K = hash.L(K);",
          "+//",
          "+//            var m1 = m.Xor(K);",
          "+//            m1 = hash.S(m1);",
          "+//            m1 = hash.P(m1);",
          "+//            m1 = hash.L(m1.Reverse().ToArray());",
          "+//            ",
          "+//            ",
          "+//            int q = 0;",
          "+//            ",
          "+//            //            Console.WriteLine(HelpText.AutoBuild(result, _ => _, _ => _));",
          "+//",
          "+//            var input = Enumerable.Range(1, 0xFFFF).Select(num => new BitArray(BitConverter.GetBytes(num)).Cast<bool>().Reverse().ToArray()).Select(bits => bits.Skip(16).ToArray()).ToArray();",
          "+//            ",
          "+////            var output = new byte[] {0x2, 0xc, 0x5, 0xb}.ToArray();",
          "+////            var output2 = new byte[] {0x8, 0x3, 0x6, 0x2}.ToArray();",
          "+//            var output = new byte[] {0xf, 0xa, 0x4, 0xc, 0x0, 0xe, 0x2, 0xf, 0xb, 0x6, 0x3, 0xf, 0x3, 0xe, 0xc, 0xb};",
          "+//            var inp = new byte[] {0xb, 0x8, 0x1, 0xf, 0xc, 0xb, 0xc, 0x5, 0x5, 0xe, 0x9, 0x4, 0xf, 0x3, 0xc, 0xf};",
          "+//",
          "+//            var output2 = L3(inp);",
          "+//",
          "+//            var b = MoreEnumerable.Batch(output, 4).Select(o => input.FirstOrDefault(t => L(t).SequenceEqual(o)))",
          "+//                .Select(",
          "+//                    bits => MoreEnumerable.Batch(bits, 4).ToArray()",
          "+//                        .Select(c => MoreEnumerable.PadStart(c, 8).ToArray()).SelectMany(k => k).ToArray()",
          "+//                ).Select(bits => MoreEnumerable.Batch(bits, 8).Select(s => new BitArray(s.Reverse().ToArray())).ToArray())",
          "+//                .SelectMany(k => k).ToArray();",
          "+//",
          "+//            var res = new byte[16];",
          "+//            ",
          "+//            for (int i = 0; i < b.Length; i++)",
          "+//            {",
          "+//                b[i].CopyTo(res, i); ",
          "+//            }",
          "+//",
          "+//            ",
          "+//            var output2_2 = L2(res);",
          "+//",
          "+//            int a = 0;",
          "             ",
          "-            var hash = new HashFunction();",
          "-",
          "-            var resultHash = hash.ComputeHash(File.ReadAllBytes(result.Value.OutputFile));",
          "             ",
          "-            File.WriteAllText(result.Value.OutputFile, resultHash);",
          "+//            var result = Parser.Default.ParseArguments<Options>(args);",
          "+//            ",
          "+//            var errors = new List<CommandLine.Error>();",
          "+//            var parserResults = result",
          "+//                    .WithNotParsed(x => errors = x.ToList())",
          "+//                ;",
          "+//",
          "+//            if (errors.Any())",
          "+//            {",
          "+//                errors.ForEach(x => Console.WriteLine(x.ToString()));",
          "+//                return;",
          "+//            }",
          "+//",
          "+//            if (result.Errors.Any())",
          "+//            {",
          "+//                throw new ArgumentException();",
          "+//            }",
          "+//",
          "+//            if (!File.Exists(result.Value.OutputFile))",
          "+//            {",
          "+//                throw new FileNotFoundException(result.Value.OutputFile);",
          "+//            }",
          "+//            ",
          "+//            var hash = new HashFunction();",
          "+//",
          "+//            var resultHash = hash.ComputeHash(File.ReadAllBytes(result.Value.OutputFile));",
          "+//            ",
          "+//            File.WriteAllText(result.Value.OutputFile, resultHash);",
          "             ",
          "             Console.ReadLine();",
          "         }",
          "diff --git a/Solution/MoraHash.Tests/MoraHash.Tests.csproj b/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "index 8b90b4b..bf2f330 100644",
          "--- a/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "+++ b/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "@@ -1,7 +1,9 @@",
          " \ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          " ",
          "     <PropertyGroup>",
          "-        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "+        <TargetFramework>net472</TargetFramework>",
          "+        <Configurations>Debug;Release</Configurations>",
          "+        <Platforms>AnyCPU;x64</Platforms>",
          "     </PropertyGroup>",
          " ",
          "     <ItemGroup>",
          "diff --git a/Solution/MoraHash/ByteUtils.cs b/Solution/MoraHash/ByteUtils.cs",
          "index bea9f6b..c366313 100644",
          "--- a/Solution/MoraHash/ByteUtils.cs",
          "+++ b/Solution/MoraHash/ByteUtils.cs",
          "@@ -1,16 +1,29 @@",
          " \ufeffusing System;",
          "+using System.Collections;",
          " using System.Collections.Generic;",
          " using System.Linq;",
          " using MoreLinq.Extensions;",
          " ",
          " namespace MoraHash",
          " {",
          "-    internal static class Utils",
          "+    public static class ByteUtils",
          "     {",
          "         public static byte[] Xor(this IEnumerable<byte> l, IEnumerable<byte> r) => l.Zip(r, (bl, br) => (bl, br)).Select(b => (byte)(b.bl ^ b.br)).ToArray();",
          "         ",
          "         public static byte[] RingSum(this IEnumerable<byte> a, IEnumerable<byte> b, int dim = 16) => a.Zip(b.Pad(a.Count()), (b1, b2) => (b1, b2))",
          "             .Select(tup => (byte) ((uint) (tup.b1 + tup.b2) % dim)).ToArray();",
          "+        ",
          "+        public static byte JoinBytes(byte hi, byte low) => (byte)((hi << 4) | (low & 0xffffffffL));",
          "+",
          "+        public static (byte hi, byte low) SplitByte(byte val) => ((byte) (val >> 4), (byte) (val & 0xf));",
          "+        ",
          "+        public static BitArray ToBitArray (this byte[] bytes, int bitCount) {",
          "+            BitArray ba = new BitArray (bitCount);",
          "+            for (int i = 0; i < bitCount; ++i) {",
          "+                ba.Set (i, ((bytes[i / 8] >> (i % 8)) & 0x01) > 0);",
          "+            }",
          "+            return ba;",
          "+        }",
          "     }",
          "     ",
          "     ",
          "diff --git a/Solution/MoraHash/Constants.cs b/Solution/MoraHash/Constants.cs",
          "index ede3480..bd3d68d 100644",
          "--- a/Solution/MoraHash/Constants.cs",
          "+++ b/Solution/MoraHash/Constants.cs",
          "@@ -1,17 +1,18 @@",
          " \ufeffnamespace MoraHash",
          " {",
          "-    internal static class Constants",
          "+    public static class Constants",
          "     {",
          "-        public static readonly byte[][] C = {",
          "-            new byte[] {0xc, 0x0, 0x1, 0x6, 0x4, 0x6, 0x3, 0x3, 0x5, 0x7, 0x5, 0xa, 0x9, 0x6, 0x9, 0x9},",
          "-            new byte[] {0x9, 0x2, 0x5, 0xb, 0x4, 0xe, 0xf, 0x4, 0x9, 0xa, 0x5, 0xe, 0x7, 0x1, 0x7, 0x4},",
          "-            new byte[] {0x8, 0x6, 0xa, 0x8, 0x9, 0xc, 0xd, 0xc, 0xf, 0x6, 0x7, 0x3, 0xb, 0xe, 0x2, 0x6},",
          "-            new byte[] {0x1, 0x8, 0x8, 0x5, 0x5, 0x5, 0x8, 0xf, 0x0, 0xe, 0xa, 0xc, 0xa, 0x3, 0xf, 0x1},",
          "-            new byte[] {0xd, 0xc, 0xf, 0xc, 0x5, 0xb, 0x8, 0x9, 0xe, 0x3, 0x5, 0xe, 0x8, 0x4, 0x3, 0x9},",
          "-            new byte[] {0x5, 0x4, 0xb, 0x9, 0xe, 0xd, 0xc, 0x7, 0x8, 0x9, 0x4, 0x6, 0x4, 0xd, 0x2, 0x3},",
          "-            new byte[] {0xf, 0x8, 0x0, 0xd, 0x4, 0x9, 0xa, 0xf, 0xd, 0xe, 0x0, 0x4, 0x4, 0xb, 0xf, 0x9},",
          "-            new byte[] {0x8, 0xc, 0xb, 0xb, 0xd, 0xf, 0x7, 0x1, 0xc, 0xc, 0xa, 0xa, 0x4, 0x3, 0xf, 0x1},",
          "-            new byte[] {0xc, 0xb, 0x4, 0x3, 0xa, 0xf, 0x7, 0x2, 0x2, 0xc, 0xb, 0x5, 0x2, 0x0, 0xb, 0x9},",
          "+        public static readonly ulong[] C =",
          "+        {",
          "+            0xc0164633575a9699,",
          "+            0x925b4ef49a5e7174,",
          "+            0x86a89cdcf673be26,",
          "+            0x86a89cdcf673be26,",
          "+            0xdcfc5b89e35e8439,",
          "+            0x54b9edc789464d23,",
          "+            0xf80d49afde044bf9,",
          "+            0x8cbbdf71ccaa43f1,",
          "+            0xcb43af722cb520b9",
          "         };",
          " ",
          "         // \u041d\u0435\u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u0431\u0438\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u044b\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432",
          "@@ -27,12 +28,20 @@",
          "         };",
          " ",
          "         // \u041b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u044b\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432.",
          "-        public static readonly byte[] L =",
          "+//        public static readonly byte[] L =",
          "+//        {",
          "+//            0x3, 0xa, 0x2, 0x2, 0x4, 0x8, 0x3, 0xb, 0x5, 0x9, 0xe, 0x5, 0xa, 0xc, 0x5, 0x2,",
          "+//            0x8, 0x5, 0x1, 0x1, 0x2, 0x4, 0x8, 0xc, 0xb, 0xd, 0x7, 0xb, 0x5, 0x6, 0xb, 0x1,",
          "+//            0x4, 0xb, 0x9, 0x9, 0x1, 0x2, 0x4, 0x6, 0xc, 0xf, 0xa, 0xc, 0xb, 0x3, 0xc, 0x9,",
          "+//            0x2, 0xc, 0xd, 0xd, 0x9, 0x1, 0x2, 0x3, 0x6, 0xe, 0x5, 0x6, 0xc, 0x8, 0x6, 0xd",
          "+//        };",
          "+        ",
          "+        public static readonly int[] L =",
          "         {",
          "-            0x3, 0xa, 0x2, 0x2, 0x4, 0x8, 0x3, 0xb, 0x5, 0x9, 0xe, 0x5, 0xa, 0xc, 0x5, 0x2,",
          "-            0x8, 0x5, 0x1, 0x1, 0x2, 0x4, 0x8, 0xc, 0xb, 0xd, 0x7, 0xb, 0x5, 0x6, 0xb, 0x1,",
          "-            0x4, 0xb, 0x9, 0x9, 0x1, 0x2, 0x4, 0x6, 0xc, 0xf, 0xa, 0xc, 0xb, 0x3, 0xc, 0x9,",
          "-            0x2, 0xc, 0xd, 0xd, 0x9, 0x1, 0x2, 0x3, 0x6, 0xe, 0x5, 0x6, 0xc, 0x8, 0x6, 0xd",
          "+            0x3a22, 0x483b, 0x59e5, 0xac52,",
          "+            0x8511, 0x248c, 0xbd7b, 0x56b1,",
          "+            0x4b99, 0x1246, 0xcfac, 0xb3c9,",
          "+            0x2cdd, 0x9123, 0x6e56 ,0xc86d",
          "         };",
          "     }",
          " }",
          "\\ No newline at end of file",
          "diff --git a/Solution/MoraHash/HashFunction.cs b/Solution/MoraHash/HashFunction.cs",
          "index b0dedb9..546a23e 100644",
          "--- a/Solution/MoraHash/HashFunction.cs",
          "+++ b/Solution/MoraHash/HashFunction.cs",
          "@@ -2,57 +2,123 @@",
          " using System.Collections;",
          " using System.Collections.Generic;",
          " using System.Linq;",
          "+using System.Threading.Tasks;",
          " using MoreLinq;",
          "-using MoreLinq.Extensions;",
          " ",
          " namespace MoraHash",
          " {",
          "     public class HashFunction",
          "     {",
          "-        private static readonly int BlockSize = 16;",
          "+        private static readonly int BlockSize = 8;",
          "         ",
          "-        private byte[] _n = new byte[64];",
          "-        private byte[] _sigma = new byte[16];",
          "-        private byte[] _iv = new byte[16];",
          "-        ",
          "-        private byte[] P(byte[] state) =>",
          "-            Enumerable.Range(0, state.Length).Select(i => state[Constants.Tau[i]]).ToArray();",
          "+        private byte[] _n = new byte[BlockSize];",
          "+        private byte[] _sigma = new byte[BlockSize];",
          "+        private byte[] _iv = new byte[BlockSize];",
          "+",
          "+        public byte[] P(byte[] state)",
          "+        {",
          "+            var tmp = new byte[16];",
          "+            var ret = new byte[8];",
          "+            for (int i = 0; i < state.Length; i++)",
          "+            {",
          "+                var splitted = ByteUtils.SplitByte(state[i]);",
          "+                tmp[i * 2] = splitted.hi;",
          "+                tmp[i * 2 + 1] = splitted.low;",
          "+            }",
          "+",
          "+            var res = Enumerable.Range(0, tmp.Length).Select(i => tmp[Constants.Tau[i]]).ToArray();",
          "+            for (int i = 0; i < ret.Length; i++)",
          "+            {",
          "+                ret[i] = ByteUtils.JoinBytes(res[i * 2], res[i * 2 + 1]);",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          " ",
          "-        private byte[] S(byte[] state) => ",
          "-            Enumerable.Range(0, state.Length).Select(i => Constants.SBox[state[i]]).ToArray();",
          "+        public byte[] S(byte[] state)",
          "+        {",
          "+            var tmp = new byte[16];",
          "+            var ret = new byte[8];",
          "+            ",
          "+            for (int i = 0; i < state.Length; i++)",
          "+            {",
          "+                var splitted = ByteUtils.SplitByte(state[i]);",
          "+                tmp[i * 2] = splitted.hi;",
          "+                tmp[i * 2 + 1] = splitted.low;",
          "+            }",
          "+            ",
          "+            var res = Enumerable.Range(0, tmp.Length).Select(i => Constants.SBox[tmp[i]]).ToArray();",
          "+            ",
          "+            for (int i = 0; i < ret.Length; i++)",
          "+            {",
          "+                ret[i] = ByteUtils.JoinBytes(res[i * 2], res[i * 2 + 1]);",
          "+            }",
          "+",
          "+            return ret;",
          "+        }",
          "         ",
          "-        private byte[] L(byte[] state) => BatchExtension.Batch(state, 4)",
          "-            .Select(bytes =>",
          "-                MoreEnumerable.Batch(Constants.L, 4)",
          "-                    .Zip(",
          "-                        BatchExtension.Batch(new BitArray(bytes.ToArray()).Cast<bool>(), 4)",
          "-                            .Where((x, index) => index % 2 == 0).SelectMany(b => b).ToArray(), (v, b) => (v, b))",
          "-                    .Where(tup => tup.b).Select(tup => tup.v).Aggregate(Utils.Xor)).SelectMany(res => res).ToArray();",
          "+        public byte[] L(byte[] state)",
          "+        {",
          "+            byte[] result = new byte[BlockSize];",
          "+//            Parallel.For(0, 4, i =>",
          "+            for (int i = 0; i < 4; i++)",
          "+            {",
          "+                byte[] t = new byte[2];",
          "+                byte[] tempArray = new byte[2];",
          "+                Array.Copy(state, i * 2, tempArray, 0, 2);",
          "+                tempArray = tempArray.Reverse().ToArray();",
          "+                var tempBits1 = tempArray.ToBitArray(16);",
          "+                bool[] tempBits = new bool[BlockSize * 2];",
          "+                tempBits1.CopyTo(tempBits, 0);",
          "+                tempBits = tempBits.Reverse().ToArray();",
          "+",
          "+                for (int j = 0; j < tempBits.Length; j++)",
          "+                {",
          "+                    if (tempBits[j])",
          "+                    {",
          "+                        var toXor = BitConverter.GetBytes(Constants.L[j]).Take(2).Reverse().ToArray();",
          "+",
          "+                        for (int k = 0; k < t.Length; k++)",
          "+                        {",
          "+                            t[k] ^= toXor[k];",
          "+                        }",
          "+                    }",
          "+                }",
          "+                Array.Copy(t, 0, result, i * 2, 2);",
          "+            }",
          "+",
          "+            return result;",
          "+        }",
          " ",
          "         private byte[] GetHash(byte[] message)",
          "         {",
          "             var h = new byte[BlockSize];",
          "             Array.Copy(_iv, h, BlockSize);",
          " ",
          "-            byte[] n0 = new byte[16];",
          "+            byte[] n0 = new byte[BlockSize];",
          " ",
          "-            IEnumerable<IEnumerable<byte>> blocks = MoreEnumerable.Batch(message, 64);",
          "-            ",
          "-            // \u0415\u0441\u043b\u0438 \u0431\u043b\u043e\u043a \u043c\u0435\u043d\u044c\u0448\u0435 64, \u044d\u0442\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435 \u043d\u0430\u0434\u043e",
          "-            MoreEnumerable.ForEach(blocks.Skip(1), msg =>",
          "+            IEnumerable<IEnumerable<byte>> blocks = MoreEnumerable.Batch(message, BlockSize);",
          "+",
          "+            MoreEnumerable.ForEach(blocks.Where(block => block.Count() >= BlockSize), block =>",
          "             {",
          "-                h = G_n(_n, h, msg);",
          "-                _n = _n.RingSum(BitConverter.GetBytes(64).ToArray());",
          "-                _sigma = _sigma.RingSum(msg);",
          "+                h = G_n(_n, h, block); ",
          "+                _n = _n.RingSum(BitConverter.GetBytes((long)64).Reverse());",
          "+                _sigma = _sigma.RingSum(block);",
          "             });",
          " ",
          "-            byte[] m = Enumerable.Append(MoreEnumerable.Pad(blocks.Last(), 63), (byte) 1).ToArray();",
          "-           ",
          "+            var lastBlockSize = blocks.Last().Count();",
          "+",
          "+            byte[] pad = MoreEnumerable",
          "+                .Append(new byte[lastBlockSize < BlockSize ? BlockSize - 1 - lastBlockSize : BlockSize - 1], (byte) 1).ToArray();",
          "+",
          "+            byte[] m = pad",
          "+                .Concat(blocks.Where(block => block.Count() < BlockSize).DefaultIfEmpty(new byte[0]).First()).ToArray();",
          "+            ",
          "             h = G_n(_n, h, m);",
          "            ",
          "-            byte[] msgLen = BitConverter.GetBytes((uint)(m.Length * 8));",
          "+            var msgLen = BitConverter.GetBytes((long)(message.Length * 8)).Reverse();",
          " ",
          "-            _n = _n.RingSum(msgLen.ToArray());",
          "+            _n = _n.RingSum(msgLen);",
          " ",
          "             _sigma = _sigma.RingSum(m);",
          " ",
          "@@ -62,9 +128,12 @@ namespace MoraHash",
          "             return h;",
          "         }",
          "         ",
          "-        private byte[] G_n(IEnumerable<byte> N, IEnumerable<byte> h, IEnumerable<byte> m) => E(L(P(S(h.Xor(N)))), m.ToArray()).Xor(h).Xor(m);",
          "+        public byte[] G_n(IEnumerable<byte> N, IEnumerable<byte> h, IEnumerable<byte> m)",
          "+        {",
          "+            return E(L(P(S(h.Xor(N)))), m.ToArray()).Xor(h).Xor(m);",
          "+        }",
          " ",
          "-        private byte[] E(byte[] k, byte[] m)",
          "+        public byte[] E(byte[] k, byte[] m)",
          "         {",
          "             byte[] state = k.Xor(m);",
          "             for (int i = 0; i < Constants.C.Length; i++)",
          "@@ -74,7 +143,7 @@ namespace MoraHash",
          "             return state;",
          "         }",
          " ",
          "-        private byte[] KeySchedule(byte[] k, int i) => L(P(S(k.Xor(Constants.C[i]))));",
          "+        private byte[] KeySchedule(byte[] k, int i) => L(P(S(k.Xor(BitConverter.GetBytes(Constants.C[i])))));",
          "         ",
          "         public string ComputeHash(byte[] message)",
          "         {",
          "diff --git a/Solution/MoraHash/MoraHash.csproj b/Solution/MoraHash/MoraHash.csproj",
          "index 26d5661..78525a4 100644",
          "--- a/Solution/MoraHash/MoraHash.csproj",
          "+++ b/Solution/MoraHash/MoraHash.csproj",
          "@@ -1,11 +1,61 @@",
          "-\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "-",
          "-    <PropertyGroup>",
          "-        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "-    </PropertyGroup>",
          "-",
          "-    <ItemGroup>",
          "-      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "-    </ItemGroup>",
          "-",
          "-</Project>",
          "+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "+<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",
          "+  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />",
          "+  <PropertyGroup>",
          "+    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>",
          "+    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>",
          "+    <ProjectGuid>{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}</ProjectGuid>",
          "+    <OutputType>Library</OutputType>",
          "+    <AppDesignerFolder>Properties</AppDesignerFolder>",
          "+    <RootNamespace>MoraHash</RootNamespace>",
          "+    <AssemblyName>MoraHash</AssemblyName>",
          "+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>",
          "+    <FileAlignment>512</FileAlignment>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugSymbols>true</DebugSymbols>",
          "+    <DebugType>full</DebugType>",
          "+    <Optimize>false</Optimize>",
          "+    <OutputPath>bin\\Debug\\</OutputPath>",
          "+    <DefineConstants>DEBUG;TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">",
          "+    <PlatformTarget>AnyCPU</PlatformTarget>",
          "+    <DebugType>pdbonly</DebugType>",
          "+    <Optimize>true</Optimize>",
          "+    <OutputPath>bin\\Release\\</OutputPath>",
          "+    <DefineConstants>TRACE</DefineConstants>",
          "+    <ErrorReport>prompt</ErrorReport>",
          "+    <WarningLevel>4</WarningLevel>",
          "+  </PropertyGroup>",
          "+  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|x64' \">",
          "+    <OutputPath>bin\\x64\\Debug\\</OutputPath>",
          "+    <PlatformTarget>x64</PlatformTarget>",
          "+  </PropertyGroup>",
          "+  <ItemGroup>",
          "+    <Reference Include=\"System\" />",
          "+    <Reference Include=\"System.Core\" />",
          "+    <Reference Include=\"System.Data\" />",
          "+    <Reference Include=\"System.Xml\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <Compile Include=\"ByteUtils.cs\" />",
          "+    <Compile Include=\"Constants.cs\" />",
          "+    <Compile Include=\"HashFunction.cs\" />",
          "+    <Compile Include=\"Properties\\AssemblyInfo.cs\" />",
          "+  </ItemGroup>",
          "+  <ItemGroup>",
          "+    <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "+  </ItemGroup>",
          "+  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />",
          "+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ",
          "+         Other similar extension points exist, see Microsoft.Common.targets.",
          "+    <Target Name=\"BeforeBuild\">",
          "+    </Target>",
          "+    <Target Name=\"AfterBuild\">",
          "+    </Target>",
          "+    -->",
          "+</Project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/Multicollisions.sln b/Solution/Multicollisions.sln",
          "index 350a716..581f3a8 100644",
          "--- a/Solution/Multicollisions.sln",
          "+++ b/Solution/Multicollisions.sln",
          "@@ -1,28 +1,44 @@",
          " \ufeff",
          " Microsoft Visual Studio Solution File, Format Version 12.00",
          "-Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash\", \"MoraHash\\MoraHash.csproj\", \"{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}\"",
          "+# Visual Studio Version 16",
          "+VisualStudioVersion = 16.0.29326.143",
          "+MinimumVisualStudioVersion = 10.0.40219.1",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash\", \"MoraHash\\MoraHash.csproj\", \"{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}\"",
          " EndProject",
          "-Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}\"",
          "+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{98508736-247B-41BB-9221-70C900431B19}\"",
          " EndProject",
          "-Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash.Tests\", \"MoraHash.Tests\\MoraHash.Tests.csproj\", \"{1B48366A-328B-49CA-86D4-C01BBD609468}\"",
          "+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MoraHash.Tests\", \"MoraHash.Tests\\MoraHash.Tests.csproj\", \"{1B48366A-328B-49CA-86D4-C01BBD609468}\"",
          " EndProject",
          " Global",
          " \tGlobalSection(SolutionConfigurationPlatforms) = preSolution",
          " \t\tDebug|Any CPU = Debug|Any CPU",
          "+\t\tDebug|x64 = Debug|x64",
          " \t\tRelease|Any CPU = Release|Any CPU",
          " \tEndGlobalSection",
          " \tGlobalSection(ProjectConfigurationPlatforms) = postSolution",
          "-\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "-\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "-\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "-\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Release|Any CPU.Build.0 = Release|Any CPU",
          "-\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "-\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "-\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "-\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|x64.ActiveCfg = Debug|x64",
          "+\t\t{8A69AA3F-5FEA-451B-9EFE-528B68BC478C}.Debug|x64.Build.0 = Debug|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.ActiveCfg = Debug|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|Any CPU.Build.0 = Debug|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|x64.ActiveCfg = Debug|x64",
          "+\t\t{98508736-247B-41BB-9221-70C900431B19}.Debug|x64.Build.0 = Debug|x64",
          " \t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          " \t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          " \t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          " \t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|x64.ActiveCfg = Debug|x64",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|x64.Build.0 = Debug|x64",
          "+\tEndGlobalSection",
          "+\tGlobalSection(SolutionProperties) = preSolution",
          "+\t\tHideSolutionNode = FALSE",
          "+\tEndGlobalSection",
          "+\tGlobalSection(ExtensibilityGlobals) = postSolution",
          "+\t\tSolutionGuid = {9CCF3A8D-80D2-4CE7-AC3E-38536F6F0EBF}",
          " \tEndGlobalSection",
          " EndGlobal",
          ""
        ],
        "b8fc964f3e81efb9009b696066ee4c8592e19ce6": [
          "commit b8fc964f3e81efb9009b696066ee4c8592e19ce6",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Sat Nov 21 16:33:03 2020 +0300",
          "",
          "    Diplom strucutre",
          "",
          "diff --git a/Images/empty_img.txt b/Images/empty_img.txt",
          "new file mode 100644",
          "index 0000000..e69de29",
          "diff --git a/Presentation/empty_presentation.txt b/Presentation/empty_presentation.txt",
          "new file mode 100644",
          "index 0000000..e69de29",
          "diff --git a/Text/empty_diploma.txt b/Text/empty_diploma.txt",
          "new file mode 100644",
          "index 0000000..e69de29",
          ""
        ],
        "7779f2ac6180f22e02ef1c0d99bb188b3a8fa768": [
          "commit 7779f2ac6180f22e02ef1c0d99bb188b3a8fa768",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Sat Nov 21 16:32:32 2020 +0300",
          "",
          "    Diplom strucutre",
          "",
          "diff --git a/.gitignore b/Solution/.gitignore",
          "similarity index 100%",
          "rename from .gitignore",
          "rename to Solution/.gitignore",
          "diff --git a/.idea/.gitignore b/Solution/.idea/.gitignore",
          "similarity index 100%",
          "rename from .idea/.gitignore",
          "rename to Solution/.idea/.gitignore",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/.name b/Solution/.idea/.idea.Multicollisions/.idea/.name",
          "new file mode 100644",
          "index 0000000..b0f4a87",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/.name",
          "@@ -0,0 +1 @@",
          "+Multicollisions",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "new file mode 100644",
          "index 0000000..ce975ed",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/contentModel.xml",
          "@@ -0,0 +1,62 @@",
          "+<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"ContentModelStore\">",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.net.test.sdk\\16.8.0\\build\\netcoreapp2.1\" t=\"Include\">",
          "+      <e p=\"Microsoft.NET.Test.Sdk.Program.cs\" t=\"Include\" />",
          "+    </e>",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.testplatform.testhost\\16.8.0\\build\\netcoreapp2.1\\x64\\testhost.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\microsoft.testplatform.testhost\\16.8.0\\build\\netcoreapp2.1\\x64\\testhost.exe\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\mstest.testadapter\\2.1.2\\build\\netcoreapp1.0\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.reporters.netcoreapp10.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.utility.netcoreapp10.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.nuget\\packages\\xunit.runner.visualstudio\\2.4.3\\build\\netcoreapp2.1\\xunit.runner.visualstudio.dotnetcore.testadapter.dll\" t=\"Include\" />",
          "+    <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\extResources\" t=\"IncludeRecursive\" />",
          "+    <e p=\"C:\\Users\\niktv\\.Rider2019.2\\system\\resharper-host\\local\\Transient\\ReSharperHost\\v192\\SolutionCaches\\_Multicollisions.-582165928.00\" t=\"ExcludeRecursive\" />",
          "+    <e p=\"C:\\Users\\niktv\\RiderProjects\\Multicollisions\\Solution\" t=\"IncludeFlat\">",
          "+      <e p=\"Algorithm\" t=\"IncludeRecursive\">",
          "+        <e p=\"Algorithm.csproj\" t=\"IncludeRecursive\" />",
          "+        <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"Multicollision.cs\" t=\"Include\" />",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "+          <e p=\"Debug\" t=\"Include\">",
          "+            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "+              <e p=\"Algorithm.AssemblyInfo.cs\" t=\"Include\" />",
          "+            </e>",
          "+          </e>",
          "+        </e>",
          "+        <e p=\"Options.cs\" t=\"Include\" />",
          "+        <e p=\"Program.cs\" t=\"Include\" />",
          "+      </e>",
          "+      <e p=\"MoraHash\" t=\"IncludeRecursive\">",
          "+        <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"ByteUtils.cs\" t=\"Include\" />",
          "+        <e p=\"Constants.cs\" t=\"Include\" />",
          "+        <e p=\"HashFunction.cs\" t=\"Include\" />",
          "+        <e p=\"MoraHash.csproj\" t=\"IncludeRecursive\" />",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "+          <e p=\"Debug\" t=\"Include\">",
          "+            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "+              <e p=\"MoraHash.AssemblyInfo.cs\" t=\"Include\" />",
          "+            </e>",
          "+          </e>",
          "+        </e>",
          "+      </e>",
          "+      <e p=\"MoraHash.Tests\" t=\"IncludeRecursive\">",
          "+        <e p=\"bin\" t=\"ExcludeRecursive\" />",
          "+        <e p=\"MoraHash.Tests.csproj\" t=\"IncludeRecursive\" />",
          "+        <e p=\"obj\" t=\"ExcludeRecursive\">",
          "+          <e p=\"Debug\" t=\"Include\">",
          "+            <e p=\"netcoreapp3.1\" t=\"Include\">",
          "+              <e p=\"MoraHash.Tests.AssemblyInfo.cs\" t=\"Include\" />",
          "+            </e>",
          "+          </e>",
          "+        </e>",
          "+        <e p=\"TestHash.cs\" t=\"Include\" />",
          "+      </e>",
          "+      <e p=\"Multicollisions.sln\" t=\"IncludeFlat\" />",
          "+      <e p=\"packages\" t=\"ExcludeRecursive\" />",
          "+    </e>",
          "+  </component>",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/encodings.xml b/Solution/.idea/.idea.Multicollisions/.idea/encodings.xml",
          "new file mode 100644",
          "index 0000000..df87cf9",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/encodings.xml",
          "@@ -0,0 +1,4 @@",
          "+<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"Encoding\" addBOMForNewFiles=\"with BOM under Windows, with no BOM otherwise\" />",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/indexLayout.xml b/Solution/.idea/.idea.Multicollisions/.idea/indexLayout.xml",
          "new file mode 100644",
          "index 0000000..6e860ad",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/indexLayout.xml",
          "@@ -0,0 +1,8 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"ContentModelUserStore\">",
          "+    <attachedFolders />",
          "+    <explicitIncludes />",
          "+    <explicitExcludes />",
          "+  </component>",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/modules.xml b/Solution/.idea/.idea.Multicollisions/.idea/modules.xml",
          "new file mode 100644",
          "index 0000000..d296853",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/modules.xml",
          "@@ -0,0 +1,8 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"ProjectModuleManager\">",
          "+    <modules>",
          "+      <module fileurl=\"file://$PROJECT_DIR$/.idea/.idea.Multicollisions/riderModule.iml\" filepath=\"$PROJECT_DIR$/.idea/.idea.Multicollisions/riderModule.iml\" />",
          "+    </modules>",
          "+  </component>",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/projectSettingsUpdater.xml b/Solution/.idea/.idea.Multicollisions/.idea/projectSettingsUpdater.xml",
          "new file mode 100644",
          "index 0000000..ce33180",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/projectSettingsUpdater.xml",
          "@@ -0,0 +1,6 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"RiderProjectSettingsUpdater\">",
          "+    <option name=\"vcsConfiguration\" value=\"1\" />",
          "+  </component>",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/.idea/vcs.xml b/Solution/.idea/.idea.Multicollisions/.idea/vcs.xml",
          "new file mode 100644",
          "index 0000000..6c0b863",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/.idea/vcs.xml",
          "@@ -0,0 +1,6 @@",
          "+<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<project version=\"4\">",
          "+  <component name=\"VcsDirectoryMappings\">",
          "+    <mapping directory=\"$PROJECT_DIR$/..\" vcs=\"Git\" />",
          "+  </component>",
          "+</project>",
          "\\ No newline at end of file",
          "diff --git a/Solution/.idea/.idea.Multicollisions/riderModule.iml b/Solution/.idea/.idea.Multicollisions/riderModule.iml",
          "new file mode 100644",
          "index 0000000..8450275",
          "--- /dev/null",
          "+++ b/Solution/.idea/.idea.Multicollisions/riderModule.iml",
          "@@ -0,0 +1,7 @@",
          "+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "+<module type=\"RIDER_MODULE\" version=\"4\">",
          "+  <component name=\"NewModuleRootManager\">",
          "+    <content url=\"file://$MODULE_DIR$/../..\" />",
          "+    <orderEntry type=\"sourceFolder\" forTests=\"false\" />",
          "+  </component>",
          "+</module>",
          "\\ No newline at end of file",
          "diff --git a/Algorithm/Algorithm.csproj b/Solution/Algorithm/Algorithm.csproj",
          "similarity index 100%",
          "rename from Algorithm/Algorithm.csproj",
          "rename to Solution/Algorithm/Algorithm.csproj",
          "diff --git a/Solution/Algorithm/Multicollision.cs b/Solution/Algorithm/Multicollision.cs",
          "new file mode 100644",
          "index 0000000..0d83ad5",
          "--- /dev/null",
          "+++ b/Solution/Algorithm/Multicollision.cs",
          "@@ -0,0 +1,10 @@",
          "+\ufeffnamespace Algorithm",
          "+{",
          "+    public class Multicollision",
          "+    {",
          "+        public void FindCollisions()",
          "+        {",
          "+            ",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Algorithm/Options.cs b/Solution/Algorithm/Options.cs",
          "similarity index 100%",
          "rename from Algorithm/Options.cs",
          "rename to Solution/Algorithm/Options.cs",
          "diff --git a/Algorithm/Program.cs b/Solution/Algorithm/Program.cs",
          "similarity index 100%",
          "rename from Algorithm/Program.cs",
          "rename to Solution/Algorithm/Program.cs",
          "diff --git a/MoraHash.Tests/MoraHash.Tests.csproj b/Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "similarity index 100%",
          "rename from MoraHash.Tests/MoraHash.Tests.csproj",
          "rename to Solution/MoraHash.Tests/MoraHash.Tests.csproj",
          "diff --git a/MoraHash.Tests/TestHash.cs b/Solution/MoraHash.Tests/TestHash.cs",
          "similarity index 100%",
          "rename from MoraHash.Tests/TestHash.cs",
          "rename to Solution/MoraHash.Tests/TestHash.cs",
          "diff --git a/MoraHash/ByteUtils.cs b/Solution/MoraHash/ByteUtils.cs",
          "similarity index 100%",
          "rename from MoraHash/ByteUtils.cs",
          "rename to Solution/MoraHash/ByteUtils.cs",
          "diff --git a/MoraHash/Constants.cs b/Solution/MoraHash/Constants.cs",
          "similarity index 100%",
          "rename from MoraHash/Constants.cs",
          "rename to Solution/MoraHash/Constants.cs",
          "diff --git a/MoraHash/HashFunction.cs b/Solution/MoraHash/HashFunction.cs",
          "similarity index 100%",
          "rename from MoraHash/HashFunction.cs",
          "rename to Solution/MoraHash/HashFunction.cs",
          "diff --git a/MoraHash/MoraHash.csproj b/Solution/MoraHash/MoraHash.csproj",
          "similarity index 100%",
          "rename from MoraHash/MoraHash.csproj",
          "rename to Solution/MoraHash/MoraHash.csproj",
          "diff --git a/Multicollisions.sln b/Solution/Multicollisions.sln",
          "similarity index 100%",
          "rename from Multicollisions.sln",
          "rename to Solution/Multicollisions.sln",
          ""
        ],
        "61a6cd9c2e197f751acbca8f204c552af61eed8c": [
          "commit 61a6cd9c2e197f751acbca8f204c552af61eed8c",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Sun Nov 8 21:48:28 2020 +0300",
          "",
          "    Update TargetFramework",
          "",
          "diff --git a/Algorithm/Algorithm.csproj b/Algorithm/Algorithm.csproj",
          "index 4eb7832..9693d6e 100644",
          "--- a/Algorithm/Algorithm.csproj",
          "+++ b/Algorithm/Algorithm.csproj",
          "@@ -2,7 +2,7 @@",
          " ",
          "     <PropertyGroup>",
          "         <OutputType>Exe</OutputType>",
          "-        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "     </PropertyGroup>",
          " ",
          "     <ItemGroup>",
          "diff --git a/MoraHash.Tests/MoraHash.Tests.csproj b/MoraHash.Tests/MoraHash.Tests.csproj",
          "index b34d91b..8b90b4b 100644",
          "--- a/MoraHash.Tests/MoraHash.Tests.csproj",
          "+++ b/MoraHash.Tests/MoraHash.Tests.csproj",
          "@@ -1,11 +1,12 @@",
          " \ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          " ",
          "     <PropertyGroup>",
          "-        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "     </PropertyGroup>",
          " ",
          "     <ItemGroup>",
          "       <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.8.0\" />",
          "+      <PackageReference Include=\"MSTest.TestAdapter\" Version=\"2.1.2\" />",
          "       <PackageReference Include=\"xunit\" Version=\"2.4.1\" />",
          "       <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.3\" />",
          "     </ItemGroup>",
          "diff --git a/MoraHash/MoraHash.csproj b/MoraHash/MoraHash.csproj",
          "index edf1ba9..26d5661 100644",
          "--- a/MoraHash/MoraHash.csproj",
          "+++ b/MoraHash/MoraHash.csproj",
          "@@ -1,7 +1,7 @@",
          " \ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          " ",
          "     <PropertyGroup>",
          "-        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+        <TargetFramework>netcoreapp3.1</TargetFramework>",
          "     </PropertyGroup>",
          " ",
          "     <ItemGroup>",
          ""
        ],
        "15448f3b65b466d4522396d151c439fe613300bc": [
          "commit 15448f3b65b466d4522396d151c439fe613300bc",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Sun Nov 8 21:25:08 2020 +0300",
          "",
          "    remove junk",
          "",
          "diff --git a/Algorithm/Options.cs b/Algorithm/Options.cs",
          "index 907021d..958c23f 100644",
          "--- a/Algorithm/Options.cs",
          "+++ b/Algorithm/Options.cs",
          "@@ -4,10 +4,6 @@ namespace Algorithm",
          " {",
          "     public class Options",
          "     {",
          "-//        [Option('h', \"help\", Required = false, Default = false,",
          "-//            HelpText = \"Help\")]",
          "-//        public bool Help { get; set; }",
          "-",
          "         [Option('i', \"input\", Required = true, Default = \"\",",
          "             HelpText =",
          "                 \"Input data file path\")]",
          "@@ -17,13 +13,5 @@ namespace Algorithm",
          "             HelpText =",
          "                 \"Output data file path\")]",
          "         public string OutputFile { get; set; }",
          "-//",
          "-//        [Option('s', \"silent\", Required = false, Default = false, HelpText = \"Disables output ...\")]",
          "-//        public bool Output { get; set; }",
          "-//",
          "-//        [Option('p', \"path\", Required = false, Default = \"../some/dir/\",",
          "-//            HelpText =",
          "-//                \"Specifies the path ...\")]",
          "-//        public string StartPath { get; set; }",
          "     }",
          " }",
          "\\ No newline at end of file",
          ""
        ],
        "f32f8da5753c0e153bca25b14b516e1af8da4c26": [
          "commit f32f8da5753c0e153bca25b14b516e1af8da4c26",
          "Author: nikta <n.i.k.tver@yandex.ru>",
          "Date:   Sun Nov 8 21:17:02 2020 +0300",
          "",
          "    \"Mora\" hash function",
          "",
          "diff --git a/.gitignore b/.gitignore",
          "new file mode 100644",
          "index 0000000..b230ab5",
          "--- /dev/null",
          "+++ b/.gitignore",
          "@@ -0,0 +1,3 @@",
          "+bin/",
          "+obj/",
          "+/packages/",
          "\\ No newline at end of file",
          "diff --git a/.idea/.gitignore b/.idea/.gitignore",
          "new file mode 100644",
          "index 0000000..c43010c",
          "--- /dev/null",
          "+++ b/.idea/.gitignore",
          "@@ -0,0 +1,3 @@",
          "+\ufeff",
          "+# Default ignored files",
          "+/.idea.Multicollisions/.idea/workspace.xml",
          "\\ No newline at end of file",
          "diff --git a/Algorithm/Algorithm.csproj b/Algorithm/Algorithm.csproj",
          "new file mode 100644",
          "index 0000000..4eb7832",
          "--- /dev/null",
          "+++ b/Algorithm/Algorithm.csproj",
          "@@ -0,0 +1,17 @@",
          "+\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "+",
          "+    <PropertyGroup>",
          "+        <OutputType>Exe</OutputType>",
          "+        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+    </PropertyGroup>",
          "+",
          "+    <ItemGroup>",
          "+      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />",
          "+    </ItemGroup>",
          "+",
          "+    <ItemGroup>",
          "+      <PackageReference Include=\"CommandLineParser\" Version=\"2.9.0-preview1\" />",
          "+      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "+    </ItemGroup>",
          "+",
          "+</Project>",
          "diff --git a/Algorithm/Options.cs b/Algorithm/Options.cs",
          "new file mode 100644",
          "index 0000000..907021d",
          "--- /dev/null",
          "+++ b/Algorithm/Options.cs",
          "@@ -0,0 +1,29 @@",
          "+\ufeffusing CommandLine;",
          "+",
          "+namespace Algorithm",
          "+{",
          "+    public class Options",
          "+    {",
          "+//        [Option('h', \"help\", Required = false, Default = false,",
          "+//            HelpText = \"Help\")]",
          "+//        public bool Help { get; set; }",
          "+",
          "+        [Option('i', \"input\", Required = true, Default = \"\",",
          "+            HelpText =",
          "+                \"Input data file path\")]",
          "+        public string InputFile { get; set; }",
          "+        ",
          "+        [Option('o', \"output\", Required = true, Default = \"\",",
          "+            HelpText =",
          "+                \"Output data file path\")]",
          "+        public string OutputFile { get; set; }",
          "+//",
          "+//        [Option('s', \"silent\", Required = false, Default = false, HelpText = \"Disables output ...\")]",
          "+//        public bool Output { get; set; }",
          "+//",
          "+//        [Option('p', \"path\", Required = false, Default = \"../some/dir/\",",
          "+//            HelpText =",
          "+//                \"Specifies the path ...\")]",
          "+//        public string StartPath { get; set; }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/Algorithm/Program.cs b/Algorithm/Program.cs",
          "new file mode 100644",
          "index 0000000..1f3aa12",
          "--- /dev/null",
          "+++ b/Algorithm/Program.cs",
          "@@ -0,0 +1,48 @@",
          "+\ufeffusing System;",
          "+using System.Collections.Generic;",
          "+using System.IO;",
          "+using System.Linq;",
          "+using CommandLine;",
          "+using CommandLine.Text;",
          "+using MoraHash;",
          "+",
          "+namespace Algorithm",
          "+{",
          "+    class Program",
          "+    {",
          "+        static void Main(string[] args)",
          "+        {",
          "+            //            Console.WriteLine(HelpText.AutoBuild(result, _ => _, _ => _));",
          "+            var result = Parser.Default.ParseArguments<Options>(args);",
          "+            ",
          "+            var errors = new List<CommandLine.Error>();",
          "+            var parserResults = result",
          "+                    .WithNotParsed(x => errors = x.ToList())",
          "+                ;",
          "+",
          "+            if (errors.Any())",
          "+            {",
          "+                errors.ForEach(x => Console.WriteLine(x.ToString()));",
          "+                return;",
          "+            }",
          "+",
          "+            if (result.Errors.Any())",
          "+            {",
          "+                throw new ArgumentException();",
          "+            }",
          "+",
          "+            if (!File.Exists(result.Value.OutputFile))",
          "+            {",
          "+                throw new FileNotFoundException(result.Value.OutputFile);",
          "+            }",
          "+            ",
          "+            var hash = new HashFunction();",
          "+",
          "+            var resultHash = hash.ComputeHash(File.ReadAllBytes(result.Value.OutputFile));",
          "+            ",
          "+            File.WriteAllText(result.Value.OutputFile, resultHash);",
          "+            ",
          "+            Console.ReadLine();",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/MoraHash.Tests/MoraHash.Tests.csproj b/MoraHash.Tests/MoraHash.Tests.csproj",
          "new file mode 100644",
          "index 0000000..b34d91b",
          "--- /dev/null",
          "+++ b/MoraHash.Tests/MoraHash.Tests.csproj",
          "@@ -0,0 +1,17 @@",
          "+\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "+",
          "+    <PropertyGroup>",
          "+        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+    </PropertyGroup>",
          "+",
          "+    <ItemGroup>",
          "+      <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.8.0\" />",
          "+      <PackageReference Include=\"xunit\" Version=\"2.4.1\" />",
          "+      <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.3\" />",
          "+    </ItemGroup>",
          "+",
          "+    <ItemGroup>",
          "+      <ProjectReference Include=\"..\\MoraHash\\MoraHash.csproj\" />",
          "+    </ItemGroup>",
          "+",
          "+</Project>",
          "diff --git a/MoraHash.Tests/TestHash.cs b/MoraHash.Tests/TestHash.cs",
          "new file mode 100644",
          "index 0000000..36f1907",
          "--- /dev/null",
          "+++ b/MoraHash.Tests/TestHash.cs",
          "@@ -0,0 +1,26 @@",
          "+\ufeffusing System;",
          "+using Xunit;",
          "+",
          "+namespace MoraHash.Tests",
          "+{",
          "+    public class TestHash : IDisposable",
          "+    {",
          "+        [Fact]",
          "+        public void Test()",
          "+        {",
          "+            var hash = new HashFunction();",
          "+            var m = new byte[] {0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7, 0x0, 0x1, 0xd, 0x4, 0x4, 0x4, 0x9, 0x0, 0x7, 0xe, 0xf, 0xb, 0x8, 0xc, 0xf, 0x7};",
          "+            ",
          "+            var res = hash.ComputeHash(m);",
          "+            ",
          "+            Assert.NotNull(res);",
          "+            Assert.NotEmpty(res);",
          "+        }",
          "+",
          "+",
          "+",
          "+        public void Dispose()",
          "+        {",
          "+        }",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/MoraHash/ByteUtils.cs b/MoraHash/ByteUtils.cs",
          "new file mode 100644",
          "index 0000000..bea9f6b",
          "--- /dev/null",
          "+++ b/MoraHash/ByteUtils.cs",
          "@@ -0,0 +1,17 @@",
          "+\ufeffusing System;",
          "+using System.Collections.Generic;",
          "+using System.Linq;",
          "+using MoreLinq.Extensions;",
          "+",
          "+namespace MoraHash",
          "+{",
          "+    internal static class Utils",
          "+    {",
          "+        public static byte[] Xor(this IEnumerable<byte> l, IEnumerable<byte> r) => l.Zip(r, (bl, br) => (bl, br)).Select(b => (byte)(b.bl ^ b.br)).ToArray();",
          "+        ",
          "+        public static byte[] RingSum(this IEnumerable<byte> a, IEnumerable<byte> b, int dim = 16) => a.Zip(b.Pad(a.Count()), (b1, b2) => (b1, b2))",
          "+            .Select(tup => (byte) ((uint) (tup.b1 + tup.b2) % dim)).ToArray();",
          "+    }",
          "+    ",
          "+    ",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/MoraHash/Constants.cs b/MoraHash/Constants.cs",
          "new file mode 100644",
          "index 0000000..ede3480",
          "--- /dev/null",
          "+++ b/MoraHash/Constants.cs",
          "@@ -0,0 +1,38 @@",
          "+\ufeffnamespace MoraHash",
          "+{",
          "+    internal static class Constants",
          "+    {",
          "+        public static readonly byte[][] C = {",
          "+            new byte[] {0xc, 0x0, 0x1, 0x6, 0x4, 0x6, 0x3, 0x3, 0x5, 0x7, 0x5, 0xa, 0x9, 0x6, 0x9, 0x9},",
          "+            new byte[] {0x9, 0x2, 0x5, 0xb, 0x4, 0xe, 0xf, 0x4, 0x9, 0xa, 0x5, 0xe, 0x7, 0x1, 0x7, 0x4},",
          "+            new byte[] {0x8, 0x6, 0xa, 0x8, 0x9, 0xc, 0xd, 0xc, 0xf, 0x6, 0x7, 0x3, 0xb, 0xe, 0x2, 0x6},",
          "+            new byte[] {0x1, 0x8, 0x8, 0x5, 0x5, 0x5, 0x8, 0xf, 0x0, 0xe, 0xa, 0xc, 0xa, 0x3, 0xf, 0x1},",
          "+            new byte[] {0xd, 0xc, 0xf, 0xc, 0x5, 0xb, 0x8, 0x9, 0xe, 0x3, 0x5, 0xe, 0x8, 0x4, 0x3, 0x9},",
          "+            new byte[] {0x5, 0x4, 0xb, 0x9, 0xe, 0xd, 0xc, 0x7, 0x8, 0x9, 0x4, 0x6, 0x4, 0xd, 0x2, 0x3},",
          "+            new byte[] {0xf, 0x8, 0x0, 0xd, 0x4, 0x9, 0xa, 0xf, 0xd, 0xe, 0x0, 0x4, 0x4, 0xb, 0xf, 0x9},",
          "+            new byte[] {0x8, 0xc, 0xb, 0xb, 0xd, 0xf, 0x7, 0x1, 0xc, 0xc, 0xa, 0xa, 0x4, 0x3, 0xf, 0x1},",
          "+            new byte[] {0xc, 0xb, 0x4, 0x3, 0xa, 0xf, 0x7, 0x2, 0x2, 0xc, 0xb, 0x5, 0x2, 0x0, 0xb, 0x9},",
          "+        };",
          "+",
          "+        // \u041d\u0435\u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u0431\u0438\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u044b\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432",
          "+        public static readonly byte[] SBox =",
          "+        {",
          "+            15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10",
          "+        };",
          "+        ",
          "+        // \u041f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043f\u043e\u043b\u0443\u0431\u0430\u0439\u0442.",
          "+        public static readonly int[] Tau =",
          "+        {",
          "+            0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15",
          "+        };",
          "+",
          "+        // \u041b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u044b\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432.",
          "+        public static readonly byte[] L =",
          "+        {",
          "+            0x3, 0xa, 0x2, 0x2, 0x4, 0x8, 0x3, 0xb, 0x5, 0x9, 0xe, 0x5, 0xa, 0xc, 0x5, 0x2,",
          "+            0x8, 0x5, 0x1, 0x1, 0x2, 0x4, 0x8, 0xc, 0xb, 0xd, 0x7, 0xb, 0x5, 0x6, 0xb, 0x1,",
          "+            0x4, 0xb, 0x9, 0x9, 0x1, 0x2, 0x4, 0x6, 0xc, 0xf, 0xa, 0xc, 0xb, 0x3, 0xc, 0x9,",
          "+            0x2, 0xc, 0xd, 0xd, 0x9, 0x1, 0x2, 0x3, 0x6, 0xe, 0x5, 0x6, 0xc, 0x8, 0x6, 0xd",
          "+        };",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/MoraHash/HashFunction.cs b/MoraHash/HashFunction.cs",
          "new file mode 100644",
          "index 0000000..b0dedb9",
          "--- /dev/null",
          "+++ b/MoraHash/HashFunction.cs",
          "@@ -0,0 +1,86 @@",
          "+\ufeffusing System;",
          "+using System.Collections;",
          "+using System.Collections.Generic;",
          "+using System.Linq;",
          "+using MoreLinq;",
          "+using MoreLinq.Extensions;",
          "+",
          "+namespace MoraHash",
          "+{",
          "+    public class HashFunction",
          "+    {",
          "+        private static readonly int BlockSize = 16;",
          "+        ",
          "+        private byte[] _n = new byte[64];",
          "+        private byte[] _sigma = new byte[16];",
          "+        private byte[] _iv = new byte[16];",
          "+        ",
          "+        private byte[] P(byte[] state) =>",
          "+            Enumerable.Range(0, state.Length).Select(i => state[Constants.Tau[i]]).ToArray();",
          "+",
          "+        private byte[] S(byte[] state) => ",
          "+            Enumerable.Range(0, state.Length).Select(i => Constants.SBox[state[i]]).ToArray();",
          "+        ",
          "+        private byte[] L(byte[] state) => BatchExtension.Batch(state, 4)",
          "+            .Select(bytes =>",
          "+                MoreEnumerable.Batch(Constants.L, 4)",
          "+                    .Zip(",
          "+                        BatchExtension.Batch(new BitArray(bytes.ToArray()).Cast<bool>(), 4)",
          "+                            .Where((x, index) => index % 2 == 0).SelectMany(b => b).ToArray(), (v, b) => (v, b))",
          "+                    .Where(tup => tup.b).Select(tup => tup.v).Aggregate(Utils.Xor)).SelectMany(res => res).ToArray();",
          "+",
          "+        private byte[] GetHash(byte[] message)",
          "+        {",
          "+            var h = new byte[BlockSize];",
          "+            Array.Copy(_iv, h, BlockSize);",
          "+",
          "+            byte[] n0 = new byte[16];",
          "+",
          "+            IEnumerable<IEnumerable<byte>> blocks = MoreEnumerable.Batch(message, 64);",
          "+            ",
          "+            // \u0415\u0441\u043b\u0438 \u0431\u043b\u043e\u043a \u043c\u0435\u043d\u044c\u0448\u0435 64, \u044d\u0442\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435 \u043d\u0430\u0434\u043e",
          "+            MoreEnumerable.ForEach(blocks.Skip(1), msg =>",
          "+            {",
          "+                h = G_n(_n, h, msg);",
          "+                _n = _n.RingSum(BitConverter.GetBytes(64).ToArray());",
          "+                _sigma = _sigma.RingSum(msg);",
          "+            });",
          "+",
          "+            byte[] m = Enumerable.Append(MoreEnumerable.Pad(blocks.Last(), 63), (byte) 1).ToArray();",
          "+           ",
          "+            h = G_n(_n, h, m);",
          "+           ",
          "+            byte[] msgLen = BitConverter.GetBytes((uint)(m.Length * 8));",
          "+",
          "+            _n = _n.RingSum(msgLen.ToArray());",
          "+",
          "+            _sigma = _sigma.RingSum(m);",
          "+",
          "+            h = G_n(n0, h, _n);",
          "+            h = G_n(n0, h, _sigma);",
          "+",
          "+            return h;",
          "+        }",
          "+        ",
          "+        private byte[] G_n(IEnumerable<byte> N, IEnumerable<byte> h, IEnumerable<byte> m) => E(L(P(S(h.Xor(N)))), m.ToArray()).Xor(h).Xor(m);",
          "+",
          "+        private byte[] E(byte[] k, byte[] m)",
          "+        {",
          "+            byte[] state = k.Xor(m);",
          "+            for (int i = 0; i < Constants.C.Length; i++)",
          "+            {",
          "+                state = L(P(S(state))).Xor(KeySchedule(k, i));",
          "+            }",
          "+            return state;",
          "+        }",
          "+",
          "+        private byte[] KeySchedule(byte[] k, int i) => L(P(S(k.Xor(Constants.C[i]))));",
          "+        ",
          "+        public string ComputeHash(byte[] message)",
          "+        {",
          "+            byte[] res = GetHash(message.ToArray());",
          "+            return BitConverter.ToString(res.ToArray()).Replace(\"-\", string.Empty);",
          "+        }",
          "+        ",
          "+    }",
          "+}",
          "\\ No newline at end of file",
          "diff --git a/MoraHash/MoraHash.csproj b/MoraHash/MoraHash.csproj",
          "new file mode 100644",
          "index 0000000..edf1ba9",
          "--- /dev/null",
          "+++ b/MoraHash/MoraHash.csproj",
          "@@ -0,0 +1,11 @@",
          "+\ufeff<Project Sdk=\"Microsoft.NET.Sdk\">",
          "+",
          "+    <PropertyGroup>",
          "+        <TargetFramework>netcoreapp3.0</TargetFramework>",
          "+    </PropertyGroup>",
          "+",
          "+    <ItemGroup>",
          "+      <PackageReference Include=\"morelinq\" Version=\"3.3.2\" />",
          "+    </ItemGroup>",
          "+",
          "+</Project>",
          "diff --git a/Multicollisions.sln b/Multicollisions.sln",
          "new file mode 100644",
          "index 0000000..350a716",
          "--- /dev/null",
          "+++ b/Multicollisions.sln",
          "@@ -0,0 +1,28 @@",
          "+\ufeff",
          "+Microsoft Visual Studio Solution File, Format Version 12.00",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash\", \"MoraHash\\MoraHash.csproj\", \"{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}\"",
          "+EndProject",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Algorithm\", \"Algorithm\\Algorithm.csproj\", \"{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}\"",
          "+EndProject",
          "+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MoraHash.Tests\", \"MoraHash.Tests\\MoraHash.Tests.csproj\", \"{1B48366A-328B-49CA-86D4-C01BBD609468}\"",
          "+EndProject",
          "+Global",
          "+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution",
          "+\t\tDebug|Any CPU = Debug|Any CPU",
          "+\t\tRelease|Any CPU = Release|Any CPU",
          "+\tEndGlobalSection",
          "+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution",
          "+\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{F556CB43-3D69-4B0D-9728-7CEF27F6AABB}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{58E8D1F7-9662-4BE0-8487-B78F8177CEC4}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.ActiveCfg = Debug|Any CPU",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Debug|Any CPU.Build.0 = Debug|Any CPU",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.ActiveCfg = Release|Any CPU",
          "+\t\t{1B48366A-328B-49CA-86D4-C01BBD609468}.Release|Any CPU.Build.0 = Release|Any CPU",
          "+\tEndGlobalSection",
          "+EndGlobal",
          ""
        ]
      }
    },
    "remote": "https://github.com/nekitos911/Multicollisions"
  }
}