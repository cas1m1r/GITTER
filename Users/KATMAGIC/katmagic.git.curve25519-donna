======================: FILES :======================
======================: BRANCHES :======================
======================: LOGINFO :======================
commit 0a06e9134fd5208a665d9ddfe25d61f9d2921a23
Author: katmagic <the.magical.kat@gmail.com>
Date:   Fri Nov 4 15:00:46 2011 -0400

    Modernize us with Python 3 support. Yay!

commit 1c2bff811be826bce283c6141cb9637dd2b8e085
Author: Adam Langley <agl@chromium.org>
Date:   Mon Oct 31 12:52:48 2011 -0400

    Fix a (harmless) stack overflow of |z|.
    
    Thanks to Chris Weiland for pointing this out.

commit c6d5793edf4ce7ad722d096da47f5b99cc186dd4
Merge: 241e364 5e60ab9
Author: Adam Langley <agl@imperialviolet.org>
Date:   Sun Oct 16 06:53:57 2011 -0700

    Merge pull request #12 from warner/no-printf
    
    Remove the "wrong-length" printf from the python module.

commit 5e60ab9c2e126c13c3d74069117c4a7f4acc6649
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 15:11:54 2011 -0700

    Remove the "wrong-length" printf from the python module.
    
    Later pythons, or gcc, complained about a mismatch between
    the %ld and the Py_ssize_t. The printf was really just there
    for initial debugging anyways, so the simplest thing is to
    remove it.

commit 241e36445a5f8f75f0987dd70b4bf8f5d2ccf55c
Merge: 2bea009 97805f4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Oct 14 14:40:33 2011 -0700

    Merge pull request #11 from warner/gitignore
    
    add all executables to .gitignore

commit 97805f4a22928b01484cfa77abfac3145b38a327
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 14:39:13 2011 -0700

    add all executables to .gitignore

commit 2bea00947bdbf2367b9e5724490f786dc13c242d
Merge: 6c69ad7 ad90b74
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Oct 14 14:37:43 2011 -0700

    Merge pull request #10 from warner/OSX-ranlib
    
    run 'ranlib' on .a files, needed to make OS-X (10.6.8) happy

commit ad90b74d0360d115a49cf2fc7997fc20a02b6193
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 14:31:47 2011 -0700

    run 'ranlib' on .a files, needed to make OS-X (10.6.8) happy
    
    Without it, I get an error when e.g. test-curve25519-donna attempts to link
    against curve25519-donna.a built by Snow Leopard's gcc-4.2.1 (as mangled by
    Apple):
    
      ld: in curve25519-donna.a, archive has no table of contents
    
    I vaguely remember modern gcc/ar producing TOCs by default, so ranlib is
    redundant these days, but this system's binutils are probably too old. I
    believe ranlib is generally harmless on other systems.

commit 6c69ad7bc990b4b3f8d5c0c9d28b9eca6952dff0
Merge: 505f613 c4aea4e
Author: Adam Langley <agl@imperialviolet.org>
Date:   Tue Oct 11 09:22:24 2011 -0700

    Merge pull request #8 from katmagic/consttime-v2
    
    Consttime v2

commit 505f613ce865945b99bec48c63fc433313eb8ea8
Merge: cb8900c b040294
Author: Adam Langley <agl@imperialviolet.org>
Date:   Tue Oct 4 16:46:23 2011 -0700

    Merge pull request #6 from nmathewson/consttime
    
    Make the 32-bit implementation almost time-invariant

commit c4aea4e2ced4f6f889d6d31a7b2e090149dffc01
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 15:17:57 2011 -0700

    Fix comment typo

commit 208ee479413b94d36024f303815136df1e9a8e93
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 09:04:06 2011 -0700

    Fix typo in Makefile

commit 7a2e9ad7e8db1256ffd58fa3dd80cf8105a0c747
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 08:22:05 2011 -0700

    Use s32 operations for borrow propagation in fcontract
    
    This seems to make curve25519-donna slower, not faster, on my AMD64 system,
    but on a friend's Atom netbook, it's a noticeable speedup.

commit aa8e3abd2bbc1d669fd0dfa9b55a6988e96f12c3
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Fri Sep 30 19:34:39 2011 -0700

    Make fcontract fully constant-time

commit b040294b06c27f96071d1d1cbbfe9f2d3ced9ce7
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 19:20:51 2011 -0400

    Do swap-conditional with 32-bit arithmetic
    
    Because all of the values in the limb-arrays are in reduced-
    coefficient form, we can cheat the swap operation a little by
    computing the result on the low 32 bits of the inputs, then
    sign-extending back to 64-bit limbs.
    
    This shaves another 2 or 3% off the runtime for me.

commit d28a6428f18a203b795c8a4fe7148e17b188bac5
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 19:05:06 2011 -0400

    Document and speed up swap_conditional
    
    The speedup is possible because we are only swapping reduced values:
    only the low 10 limbs matter.
    
    This patch cuts the cost of my previous const-time branch approximately
    in half.

commit 16b18a3aed88eab1e08c1b2787b4ecc3ae4fd9c7
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 17:27:03 2011 -0400

    Make fcontract almost time-invariant by replacing the inner loops
    
    We replace the old
    
               while (input[i] < 0) {
                 input[i] += 0x2000000;
                 input[i + 1]--;
               }
    
    with
    
               const limb mask = input[i]>>63;
               const limb carry = -((input[i] & mask)>>25);
               input[i] += carry << 25;
               input[i+1] -= carry;
    
    This requires a compiler where >> does sign extension on negative
    numbers, but that's true pretty much everyplace, right?
    
    The "mask" value gives us a way to leave the inputs unchanged if
    input[i] >= 0.  The "carry" value works out to the number of times we
    would have run through the loop.
    
    This patch actually speeds fcontract() up a little, but fcontract is
    not enough of the overal curve25519-donna profile to matter.
    
    There is a remaining data-dependency in fcontract in the outer "do { }
    while (input[0] < 0)" loop.

commit d8ae719da05b8602b5ec1f2c1ce36dc5d2f8f231
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 11:03:08 2011 -0400

    Use swap_conditional to fix data-dependent timing in cmult
    
    Branching based on secret inputs can leak them to an attacker.  Let's
    not do that.  This patch uses the same trick as in
    curve25519-donna-c64 to make cmult() run in constant time.
    
    It comes at a price, of course; an 8-18% performance hit, depending on
    where I measure.  Still, there's no point in doing crypto fast if we
    can't do it securely.

commit cb8900c919c915ac2ee4a3f33b29a6276ed6ff6a
Merge: da2a29c 69f90c4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 24 08:09:13 2011 -0700

    Merge pull request #5 from nmathewson/fix_printf_warning
    
    Fix a gcc warning in speed-curve25519.c

commit da2a29ce8a6418ac489a0aee89a2ccca603f9e59
Merge: 7c01222 5dd8462
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 24 08:08:51 2011 -0700

    Merge pull request #4 from nmathewson/reduce_loosely
    
    Another performance improvement for freduce_coefficients

commit 69f90c4a8e5baf58a400c60b0cab3ce1241dc116
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 15:20:39 2011 -0400

    Fix a gcc warning in speed-curve25519.c
    
    It's not kosher to format a uint64_t with %lu: long is quite often
    less than 64 bits wide.  Fortunately, the value that we want to format
    here is the number of usec per operation, which won't brush up against
    LONG_MAX unless you've pessimized the code until it takes over an hour
    per call.

commit 5dd8462a31988ce88189aa37199e4344d1774066
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 15:07:15 2011 -0400

    Remove a needless freduce_degree
    
    fscalar_product cannot increase the degree of a value, but we were
    calling freduce_degree after it anyway.

commit b83a3d866982607b388fa67d33bb431a387e4163
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 14:50:59 2011 -0400

    Only do the first 2 steps of 2nd freduce_coefficients loop
    
    See the inline comments for an explanation of the implications
    here: after you've done the first pass through the coefficients,
    carried output[10] forward to output[0], and reduced output[1] and
    output[2], you're in a "nearly reduced" state where everything but
    output[2] is reduced, and |output[2]| <= 2^26.  (That is, it is
    over by at most one.)
    
    Since the largest value we compute before doing a freduce_degree
    freduce_coefficients operation is a product of two sums, it's easy
    to show that even if output[2] is equal to +/- 2^26, the inputs to
    freduce_coefficients will all be under 2^61, which meets our
    requirements.
    
    The only operation that requires its inputs in fully-reduced form
    is fcontract.  Fortunately, running an extra freduce_coefficients
    on a "nearly reduced" value produces a reduced value. This happens
    because if the value is fully-reduced, no carry operations will
    happen, and if it is reduced except for output[2]=+/-2^26,
    output[2] will become 0 and subsequent carry values will be at
    most +/-1, thus stopping with output[2] equal to either 1 or 0,
    which is then fully reduced.
    
    This patch improves speed-curve25519-donna by about 13-14% on my
    core2 laptop building with GCC 4.0.

commit 7c01222c5ad98b6a03190aa192f597ff199a66a7
Author: Adam Langley <agl@chromium.org>
Date:   Fri Jun 10 14:40:21 2011 -0400

    I didn't mean to change the speed iteration count in the last commit

commit fa41e9b958309f3a1716c31d5d2b71af7e3cd9a0
Author: Adam Langley <agl@chromium.org>
Date:   Fri Jun 10 10:39:38 2011 -0400

    Remove the fallback code for non-2's complement systems.

commit 39a31ae03ee69fb7f56bfde691df631667c6fbb0
Merge: 234205f 7d8f461
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 10 07:10:45 2011 -0700

    Merge pull request #3 from nmathewson/faster_reduce_coefficients_v2
    
    Various improvements to freduce_coefficients, v2

commit 7d8f4617c061bcc9b3ec3224c046d8060cad81d6
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 9 14:42:59 2011 -0400

    Reorder operations in 32-bit freduce_coefficients
    
    Previously each loop iteration did its accesses in the order:
       output[i], output[i+1], output[i],
       output[i+1], output[i+2], output[i+1]
    Now each iteration does:
       output[i], output[i], output[i+1]
       output[i+1], output[i+1], output[i+2]
    
    This turns out to matter on some architectures; for me it reduces
    the speed-curve25519-donna output by 3.7% (building with gcc 4.6).

commit 33274d2f8c3893a3c7a4cb26dbdbb276871fcb84
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 9 12:37:47 2011 -0400

    Improve speed and time-invariance of 32-bit freduce_coefficients
    
    Trick #1:
    
    Bizarrely, when told to generate 32-bit code for dividing int64_t by
    0x4000000l, gcc 4.6 (and probably earlier) generate code that
    contains an imul and a mul instruction, with a few shifts and adds.
    (This isn't as simple as just doing v>>26, since >> rounds negative
    numbers differently than /.  Fortunately, there's an easy
    bit-twiddling trick that I copied from clang.)
    
    The new code here is surrounded with an #ifdef TWOS_COMPLEMENT, so
    that it won't break weird chips.
    
    Trick #2:
    
    In the second iteration of the outer loop, only output[0] can be
    more than 32 bits wide: all the other output values will stay well
    under 32 bits.  Thus, we can manipulate them as s32 rather than as
    s64, saving a few more cycles.
    
    Trick #3:
    
    Also, this patch use the same trick as in freduce_degree to make
    the multiply-by-19 avoid 64-bit multiplication.
    
    Timing-invariance:
    
    The code now always runs through the outer loop twice or more.
    Previously, it would run through it sometimes once and sometimes
    twice.  (Three times is possible, but almost never happens.  We
    should still investigate whether we can cut down from two/three
    iterations to just two.)
    
    Together, these changes reduce the output of speed-curve25519-donna
    from 1415us to 1244us on my core2 desktop.

commit 234205ff1ecaf6b3c1dc76798a462c4293f31fdb
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 15:06:02 2011 -0400

    Update a couple of comments that missed the last commit

commit cf95fd4df2821d12137b09c28e29e0eb72fb2f50
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 14:11:06 2011 -0400

    Build 32-bit code in 32-bit mode and add comment.

commit c5ba8141422bcac53f1978227cd08fc76c290c30
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:49:46 2011 -0400

    Replace 64-bit mults by shifts and adds

commit 9666993f5bf49b07e92bd878015e94b57a967fe7
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:40:57 2011 -0400

    Switch to 32-bit mults

commit 0a2b79557a75e60906a67b77d6fd1d4da0b4429d
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:31:01 2011 -0400

    Rename felem to limb in order to match the NIST P-curve code

commit 78f3608ef90ff25f0701e52d635ac685ac5f52de
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 12:53:28 2011 -0400

    Simplify 32-bit freduce_coefficients.
    
    Speed up from 532us -> 466us.

commit 4302b45dcb584b022ed0c560f0ccb597ce401463
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 11:10:28 2011 -0400

    Fix whitespace in 32-bit code (no code changes)

commit 6f00f5824a24d1edcdb90f552abe57c168d18548
Author: Adam Langley <agl@imperialviolet.org>
Date:   Sat Jan 29 15:02:51 2011 -0500

    Cheery-pick changes from floodyberry.
    
    The previous change is a merge from floodyberry. The important,
    algorithmic change in it is that the multiplication by 19 can be
    performed on one of the 64-bit inputs to the 64x64 multiplication. This
    is much better than multipling the 128-bit result by 19.
    
    The rest of the changes involve persuading the compiler to do a better
    job.
    
    In this change, I've taken some of floodyberry's changes only. This is
    because I favour a different balence between speed and readability.
    
    The only algorithmic change in this commit is new way of handing
    subtractions in the field. This is thanks to an idea from Emilia Kasper.
    
    If you want the fastest code possible, take the previous commit and
    replace the fdifference_backwards with the version from this commit.

commit 008aa9a69505362a73908fb42e592af4cf0fc3d8
Author: floodyberry <liquidsun@gmail.com>
Date:   Sat Nov 13 23:39:51 2010 -0600

    remove errant tabs

commit e77c1425712d7b3052beca7f00f36a98722e0541
Author: floodyberry <liquidsun@gmail.com>
Date:   Sat Nov 13 22:35:25 2010 -0600

    re-organized to avoid 128bit math at all costs. much faster now!
    
    mainloop & recip simplified and tightened
    
    fexpand & fcontract do bytewise reads&writes to avoid unaligned access
    issues (needed? unsure, but safer)

commit 6483797174a227d791ef367b9a7d6f75f206c796
Author: Brian Warner <warner@lothar.com>
Date:   Sat Feb 20 01:12:30 2010 +0800

    add a simple OOPish python binding, with tests and basic speed test
    
    curve25519 is simple enough to get a basic functional wrapper, but I wrote it
    OOP-style so it'll be harder to accidentally swap public and private keys

commit 80d716dba64b583386daa9be7ce9dce1b91607da
Author: Brian Warner <warner@lothar.com>
Date:   Fri Feb 19 06:01:11 2010 +0800

    ignore generated files

commit e48d4728c4eadd3e9232c4f732eb41f7938ccf45
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 15 17:33:37 2009 -0700

    c64: add additional step to carry chains
    
    Thanks to Alexander Sotirov to pushing me to check that the carry chains in
    donna-c64 were sufficient. I don't know if I realised something when I wrote it
    which I'm currently missing, or if I just screwed up, but I now believe that
    they're wrong:
    
    ----- start paste
    
    This Haskell code has been written to experiment with the carry chains in
    curve25519-donna-c64. It's a literate Haskell program, one can load it into
    GHCI and play along.
    
    > module Main where
    >
    > import Data.Bits (shiftR, (.&.))
    
    There are two constants that we'll need.
    
    Our five limbs are, nominally, 51 bits wide, so this is the maximum value of
    their initial values.
    
    > twoFiftyOneMinusOne = (2 ^ 51) - 1
    
    2^128 - 1 is the limit of the range of our temporary variables. If we exceed
    this at any point, our calculations will be incorrect.
    
    > two128MinusOne = (2 ^ 128) - 1
    
    Now we define a type which mimics our 128-bit unsigned type in C. It's a
    disjuction of an Integer and the distinguished value 'Overflow'. 'Overflow' is
    contagious: if we try to perform any operations where one or both of the
    operands is 'Overflow', then the result is also 'Overflow'.
    
    > data U128 = U128 Integer
    >           | Overflow
    >           deriving (Show, Eq)
    
    We make U128 an instance of Num so that we can perform arithmetic with it.
    
    > instance Num U128 where
    >   (U128 a) + (U128 b) = mayOverflow (a + b)
    >   _ + _ = Overflow
    >   (U128 a) * (U128 b) = mayOverflow (a * b)
    >   _ * _ = Overflow
    >   (U128 a) - (U128 b) = mayOverflow (a - b)
    >   _ - _ = Overflow
    >   negate _ = Overflow
    >   abs a@(U128 _) = a
    >   abs _ = Overflow
    >   signum (U128 _) = 1
    >   signum _ = 0
    >   fromInteger = mayOverflow
    
    > instance Ord U128 where
    >   compare (U128 a) (U128 b) = compare a b
    >   compare _ _ = EQ
    
    This function lifts an Integer to a U128. If the value is out of range, the
    result is 'Overflow'
    
    > mayOverflow :: Integer -> U128
    > mayOverflow x
    >   | x > two128MinusOne = Overflow
    >   | x < 0 = Overflow
    >   | otherwise = U128 x
    
    Our field elements consist of five limbs. In the C code, these limbs are
    actually uint64_t's, but we keep them as U128's here. We will convince ourselves
    that we don't hit any 64-bit overflows later.
    
    > data FieldElement = FieldElement { m0 :: U128, m1 :: U128, m2 :: U128,
    >                                    m3 :: U128, m4 :: U128 }
    >                                  deriving (Show, Eq)
    
    Now, two helper functions:
    
    This function takes only the bottom 51-bits of a value
    
    > clamp :: U128 -> U128
    > clamp (U128 a) = U128 $ a .&. 0x7ffffffffffff
    > clamp _ = Overflow
    
    This function drop the bottom 51-bits of a value
    
    > topBits :: U128 -> U128
    > topBits (U128 a) = U128 $ a `shiftR` 51
    > topBits _ = Overflow
    
    This function simulates the 'fsquare' function in donna-c64, including its carry
    chain. If the carry chain is sufficient, then iterating this function for any
    valid initial value should never overflow.
    
    > square :: FieldElement -> FieldElement
    > square e = result where
    >   t0 = m0 e * m0 e
    >   t1 = m0 e * m1 e +
    >        m1 e * m0 e
    >   t2 = m0 e * m2 e +
    >        m2 e * m0 e +
    >        m1 e * m1 e
    >   t3 = m0 e * m3 e +
    >        m3 e * m0 e +
    >        m1 e * m2 e +
    >        m2 e * m1 e
    >   t4 = m0 e * m4 e +
    >        m4 e * m0 e +
    >        m3 e * m1 e +
    >        m1 e * m3 e +
    >        m2 e * m2 e
    >   t5 = m4 e * m1 e +
    >        m1 e * m4 e +
    >        m2 e * m3 e +
    >        m3 e * m2 e
    >   t6 = m4 e * m2 e +
    >        m2 e * m4 e +
    >        m3 e * m3 e
    >   t7 = m3 e * m4 e +
    >        m4 e * m3 e
    >   t8 = m4 e * m4 e
    >
    >   t0' = t0 + t5 * 19
    >   t1' = t1 + t6 * 19
    >   t2' = t2 + t7 * 19
    >   t3' = t3 + t8 * 19
    >
    >   t1'' = t1' + topBits t0'
    >   t2'' = t2' + topBits t1''
    >   t3'' = t3' + topBits t2''
    >   t4' = t4 + topBits t3''
    >   t0'' = t0' + 19 * topBits t4'
    >   t1''' = clamp t1'' + topBits t0''
    
    At this point, we implement two carry chains. If 'currentChain' is true, then we
    implement the carry chain as currently written in donna-c64. Otherwise, we
    perform an extra step and carry t1 into t2.
    
    >   result = if currentChain
    >               then FieldElement (clamp t0'') t1''' (clamp t2'') (clamp t3'')
    >                                 (clamp t4')
    >               else FieldElement (clamp t0'') (clamp t1''') t2''' (clamp t3'')
    >                                 (clamp t4') where
    >                    t2''' = clamp t2'' + topBits t1'''
    
    This is the maximum initial element: an element where all limbs are 2^51 - 1.
    Inspection of the 'fexpand' function should be sufficient to convince oneself of
    this.
    
    > maxInitialElement :: FieldElement
    > maxInitialElement = FieldElement twoFiftyOneMinusOne twoFiftyOneMinusOne
    >                                  twoFiftyOneMinusOne twoFiftyOneMinusOne
    >                                  twoFiftyOneMinusOne
    
    This function takes two field elements and returns the worst case result: one
    where the maximum of each limb is chosen.
    
    > elementWiseMax :: FieldElement -> FieldElement -> FieldElement
    > elementWiseMax x y = FieldElement (f m0) (f m1) (f m2) (f m3) (f m4) where
    >   f :: (FieldElement -> U128) -> U128
    >   f accessor = max (accessor x) (accessor y)
    
    We now define a series of values generated by squaring the previous element and
    setting any limb that is less than the maximum to the maximum value.
    
    > maxSeries = iterate (elementWiseMax maxInitialElement . square)
    >                     maxInitialElement
    
    This value controls which carry chain is used in 'square', the current one or
    the one with the extra carry
    
    > currentChain = False
    
    By running this, we can see that the current carry chain is insufficient for
    this simulation:
    
    ghci> maxSeries !! 4
    FieldElement {m0 = Overflow, m1 = Overflow, m2 = Overflow, m3 = Overflow,
                  m4 = Overflow}
    
    The series overflows after only four iterations. However, if we use the
    alternative carry chain, the series is stable far beyound the requirements of
    the Montgomery ladder used in donna-c64:
    
    ghci> maxSeries !! 100000
    FieldElement {m0 = U128 2251799813685247, m1 = U128 2251799813685247,
                  m2 = U128 2251799813685247, m3 = U128 2251799813685247,
                  m4 = U128 2251799813685247}
    
    Additionally, these values are small enough not to overflow the 64-limb limbs.

commit e186866b8d31a4a74f5bdc3dfd19b1e73e876e96
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 14:12:25 2009 -0700

    Remove x86-64 version.
    
    With GCC 4.3, donna-c64 is now faster than donna-x86-64 on a Core2!
    Because of this, I'm removing the x86-64 version. Everyone should
    use c64 on 64-bit systems now.

commit fab6b1b0221b08474f1726875c24461520565593
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 13:52:34 2009 -0700

    donna-x86-64: port fcontract from c64
    
    This takes djb's fcontract from donna-c64 and uses it in x86-64.

commit f2f2a71966458ecce2bef9fdf3d9d90946161963
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 12:58:38 2009 -0700

    Update fcontact in c64 with djb's version
    
    djb:
    I've expanded fcontract() in donna_c64 to do two extra rounds of carries
    and to reduce [0,2^255-1] to [0,2^255-20]. I haven't written down bounds
    on the intermediate variable sizes, and I haven't done artificial tests
    of the cases where the extra code would make a difference. I thought
    about modifying donna similarly, but donna_c64 is faster than donna on
    the most important target CPU (Core 2), so for the moment NaCl just uses
    donna_c64.

commit 21e17010f3d31374549f404b362d41dcc76f8de8
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 15:00:03 2008 -0700

    Add c64 to the `make test` target

commit a9fe4af0ede6b4bf94c461b39976584d018650d0
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 14:59:16 2008 -0700

    donna: final copy of the API change
    
    Masking and oring the secret is now the job of the curve25519 function. This is
    to match the API in NaCl.

commit 84d871d09a8d26962eeb88b3f7d59520ec539425
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 14:22:47 2008 -0700

    x86-64: make constant speed
    
    Thanks to djb for the review and suggestions

commit 06d0426d9a3c0b61d7438a64c329af122d66c2e3
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 12:17:25 2008 -0700

    Make c64 really side-channel free
    
    Thanks to djb for the review and suggested changes.

commit a07f33119ea0d09c93c1fb19937a9a25ef390047
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 11:09:38 2008 -0700

    API change: the masking and oring of bits is now performed in the curve25519
    function to match the API of NaCl.

commit f22a1dd27f9e8c027006f81e5d46fc6d3b062a75
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 15:53:57 2008 -0700

    Add the correct ELF visibility to fmonty (allows shared library building)

commit 0f02e43e1a151e57833e25d626d5a3cead3a9ef5
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:20:33 2008 -0700

    Last couple of fix ups.

commit a18738034a8ffa4cfa8722598ea8ba6e555b7327
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:19:04 2008 -0700

    Put c64 into public domain (thanks cdibona)

commit 6897a177ffd68faeeff39716da9a63c22d2a82ed
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:17:36 2008 -0700

    Implement fsquare for c64. Down to 240us.

commit b3f74a508b1e69ac3a292c604a7a6a56b727af31
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:09:45 2008 -0700

    Add new implementation: c64
    
    Side channel clean, pure C. Runs in 275us on a Core2 2.3GHz. Uses gcc's mode TI
    support to implement a 51-bit limb pattern for 64-bit platforms.

commit 1bafece6583e05c35209d4da9b7047863e8d81cc
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:17:10 2008 -0700

    Fix warning in test-curve25519

commit 0e09c6ca4010a0cb184a69fae8d85c7f6ee118c4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:14:45 2008 -0700

    Fix a couple of warnings and some typos in the Makefile

commit 16249ed62d4f3ed401131e4317f511e63c3126d4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:12:19 2008 -0700

    x86-64: Add a test for constant timing

commit a3b51177f98945cd2e4aba4ad535eaa948213865
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:54:14 2008 -0700

    Add speed tests

commit 5dbc908bfbaec66cbdeb8948ce6fe34d4bdb772a
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:53:27 2008 -0700

    Use fsquare in a few more places

commit 5250732d0f37b6577a92ebc73a73c722e803d0f0
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:38:36 2008 -0700

    Make the test abort if anything fails

commit cecd37594eb3df9883ae9cfca7f29c1877683046
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:36:11 2008 -0700

    x86-64: make carry chains constant time

commit 889feb4e98e023cc60f146721f8b6bba2425396e
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:31:32 2008 -0700

    x86-64: Replace a C function using an if statement with asm code
    
    The if statement isn't constant time, so it has to go.

commit 8d0e542af7e035e0640a8a8489848e86498fd627
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:51:34 2008 -0700

    Switch copyright of x86-64 to public domain at the request of djb

commit fef0c248f4a34fe6d84f64e634dab6842a3aef3a
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:46:56 2008 -0700

    Add test suite

commit a0e25d631b48474aca391352a3899e66f7bd313d
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:43:57 2008 -0700

    Initial import
======================: FILES :======================
======================: BRANCHES :======================
======================: LOGINFO :======================
commit 0a06e9134fd5208a665d9ddfe25d61f9d2921a23
Author: katmagic <the.magical.kat@gmail.com>
Date:   Fri Nov 4 15:00:46 2011 -0400

    Modernize us with Python 3 support. Yay!

commit 1c2bff811be826bce283c6141cb9637dd2b8e085
Author: Adam Langley <agl@chromium.org>
Date:   Mon Oct 31 12:52:48 2011 -0400

    Fix a (harmless) stack overflow of |z|.
    
    Thanks to Chris Weiland for pointing this out.

commit c6d5793edf4ce7ad722d096da47f5b99cc186dd4
Merge: 241e364 5e60ab9
Author: Adam Langley <agl@imperialviolet.org>
Date:   Sun Oct 16 06:53:57 2011 -0700

    Merge pull request #12 from warner/no-printf
    
    Remove the "wrong-length" printf from the python module.

commit 5e60ab9c2e126c13c3d74069117c4a7f4acc6649
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 15:11:54 2011 -0700

    Remove the "wrong-length" printf from the python module.
    
    Later pythons, or gcc, complained about a mismatch between
    the %ld and the Py_ssize_t. The printf was really just there
    for initial debugging anyways, so the simplest thing is to
    remove it.

commit 241e36445a5f8f75f0987dd70b4bf8f5d2ccf55c
Merge: 2bea009 97805f4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Oct 14 14:40:33 2011 -0700

    Merge pull request #11 from warner/gitignore
    
    add all executables to .gitignore

commit 97805f4a22928b01484cfa77abfac3145b38a327
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 14:39:13 2011 -0700

    add all executables to .gitignore

commit 2bea00947bdbf2367b9e5724490f786dc13c242d
Merge: 6c69ad7 ad90b74
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Oct 14 14:37:43 2011 -0700

    Merge pull request #10 from warner/OSX-ranlib
    
    run 'ranlib' on .a files, needed to make OS-X (10.6.8) happy

commit ad90b74d0360d115a49cf2fc7997fc20a02b6193
Author: Brian Warner <warner@lothar.com>
Date:   Fri Oct 14 14:31:47 2011 -0700

    run 'ranlib' on .a files, needed to make OS-X (10.6.8) happy
    
    Without it, I get an error when e.g. test-curve25519-donna attempts to link
    against curve25519-donna.a built by Snow Leopard's gcc-4.2.1 (as mangled by
    Apple):
    
      ld: in curve25519-donna.a, archive has no table of contents
    
    I vaguely remember modern gcc/ar producing TOCs by default, so ranlib is
    redundant these days, but this system's binutils are probably too old. I
    believe ranlib is generally harmless on other systems.

commit 6c69ad7bc990b4b3f8d5c0c9d28b9eca6952dff0
Merge: 505f613 c4aea4e
Author: Adam Langley <agl@imperialviolet.org>
Date:   Tue Oct 11 09:22:24 2011 -0700

    Merge pull request #8 from katmagic/consttime-v2
    
    Consttime v2

commit 505f613ce865945b99bec48c63fc433313eb8ea8
Merge: cb8900c b040294
Author: Adam Langley <agl@imperialviolet.org>
Date:   Tue Oct 4 16:46:23 2011 -0700

    Merge pull request #6 from nmathewson/consttime
    
    Make the 32-bit implementation almost time-invariant

commit c4aea4e2ced4f6f889d6d31a7b2e090149dffc01
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 15:17:57 2011 -0700

    Fix comment typo

commit 208ee479413b94d36024f303815136df1e9a8e93
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 09:04:06 2011 -0700

    Fix typo in Makefile

commit 7a2e9ad7e8db1256ffd58fa3dd80cf8105a0c747
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Sat Oct 1 08:22:05 2011 -0700

    Use s32 operations for borrow propagation in fcontract
    
    This seems to make curve25519-donna slower, not faster, on my AMD64 system,
    but on a friend's Atom netbook, it's a noticeable speedup.

commit aa8e3abd2bbc1d669fd0dfa9b55a6988e96f12c3
Author: Robert Ransom <rransom.8774@gmail.com>
Date:   Fri Sep 30 19:34:39 2011 -0700

    Make fcontract fully constant-time

commit b040294b06c27f96071d1d1cbbfe9f2d3ced9ce7
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 19:20:51 2011 -0400

    Do swap-conditional with 32-bit arithmetic
    
    Because all of the values in the limb-arrays are in reduced-
    coefficient form, we can cheat the swap operation a little by
    computing the result on the low 32 bits of the inputs, then
    sign-extending back to 64-bit limbs.
    
    This shaves another 2 or 3% off the runtime for me.

commit d28a6428f18a203b795c8a4fe7148e17b188bac5
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 19:05:06 2011 -0400

    Document and speed up swap_conditional
    
    The speedup is possible because we are only swapping reduced values:
    only the low 10 limbs matter.
    
    This patch cuts the cost of my previous const-time branch approximately
    in half.

commit 16b18a3aed88eab1e08c1b2787b4ecc3ae4fd9c7
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 17:27:03 2011 -0400

    Make fcontract almost time-invariant by replacing the inner loops
    
    We replace the old
    
               while (input[i] < 0) {
                 input[i] += 0x2000000;
                 input[i + 1]--;
               }
    
    with
    
               const limb mask = input[i]>>63;
               const limb carry = -((input[i] & mask)>>25);
               input[i] += carry << 25;
               input[i+1] -= carry;
    
    This requires a compiler where >> does sign extension on negative
    numbers, but that's true pretty much everyplace, right?
    
    The "mask" value gives us a way to leave the inputs unchanged if
    input[i] >= 0.  The "carry" value works out to the number of times we
    would have run through the loop.
    
    This patch actually speeds fcontract() up a little, but fcontract is
    not enough of the overal curve25519-donna profile to matter.
    
    There is a remaining data-dependency in fcontract in the outer "do { }
    while (input[0] < 0)" loop.

commit d8ae719da05b8602b5ec1f2c1ce36dc5d2f8f231
Author: Nick Mathewson <nickm@torproject.org>
Date:   Fri Sep 30 11:03:08 2011 -0400

    Use swap_conditional to fix data-dependent timing in cmult
    
    Branching based on secret inputs can leak them to an attacker.  Let's
    not do that.  This patch uses the same trick as in
    curve25519-donna-c64 to make cmult() run in constant time.
    
    It comes at a price, of course; an 8-18% performance hit, depending on
    where I measure.  Still, there's no point in doing crypto fast if we
    can't do it securely.

commit cb8900c919c915ac2ee4a3f33b29a6276ed6ff6a
Merge: da2a29c 69f90c4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 24 08:09:13 2011 -0700

    Merge pull request #5 from nmathewson/fix_printf_warning
    
    Fix a gcc warning in speed-curve25519.c

commit da2a29ce8a6418ac489a0aee89a2ccca603f9e59
Merge: 7c01222 5dd8462
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 24 08:08:51 2011 -0700

    Merge pull request #4 from nmathewson/reduce_loosely
    
    Another performance improvement for freduce_coefficients

commit 69f90c4a8e5baf58a400c60b0cab3ce1241dc116
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 15:20:39 2011 -0400

    Fix a gcc warning in speed-curve25519.c
    
    It's not kosher to format a uint64_t with %lu: long is quite often
    less than 64 bits wide.  Fortunately, the value that we want to format
    here is the number of usec per operation, which won't brush up against
    LONG_MAX unless you've pessimized the code until it takes over an hour
    per call.

commit 5dd8462a31988ce88189aa37199e4344d1774066
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 15:07:15 2011 -0400

    Remove a needless freduce_degree
    
    fscalar_product cannot increase the degree of a value, but we were
    calling freduce_degree after it anyway.

commit b83a3d866982607b388fa67d33bb431a387e4163
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 23 14:50:59 2011 -0400

    Only do the first 2 steps of 2nd freduce_coefficients loop
    
    See the inline comments for an explanation of the implications
    here: after you've done the first pass through the coefficients,
    carried output[10] forward to output[0], and reduced output[1] and
    output[2], you're in a "nearly reduced" state where everything but
    output[2] is reduced, and |output[2]| <= 2^26.  (That is, it is
    over by at most one.)
    
    Since the largest value we compute before doing a freduce_degree
    freduce_coefficients operation is a product of two sums, it's easy
    to show that even if output[2] is equal to +/- 2^26, the inputs to
    freduce_coefficients will all be under 2^61, which meets our
    requirements.
    
    The only operation that requires its inputs in fully-reduced form
    is fcontract.  Fortunately, running an extra freduce_coefficients
    on a "nearly reduced" value produces a reduced value. This happens
    because if the value is fully-reduced, no carry operations will
    happen, and if it is reduced except for output[2]=+/-2^26,
    output[2] will become 0 and subsequent carry values will be at
    most +/-1, thus stopping with output[2] equal to either 1 or 0,
    which is then fully reduced.
    
    This patch improves speed-curve25519-donna by about 13-14% on my
    core2 laptop building with GCC 4.0.

commit 7c01222c5ad98b6a03190aa192f597ff199a66a7
Author: Adam Langley <agl@chromium.org>
Date:   Fri Jun 10 14:40:21 2011 -0400

    I didn't mean to change the speed iteration count in the last commit

commit fa41e9b958309f3a1716c31d5d2b71af7e3cd9a0
Author: Adam Langley <agl@chromium.org>
Date:   Fri Jun 10 10:39:38 2011 -0400

    Remove the fallback code for non-2's complement systems.

commit 39a31ae03ee69fb7f56bfde691df631667c6fbb0
Merge: 234205f 7d8f461
Author: Adam Langley <agl@imperialviolet.org>
Date:   Fri Jun 10 07:10:45 2011 -0700

    Merge pull request #3 from nmathewson/faster_reduce_coefficients_v2
    
    Various improvements to freduce_coefficients, v2

commit 7d8f4617c061bcc9b3ec3224c046d8060cad81d6
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 9 14:42:59 2011 -0400

    Reorder operations in 32-bit freduce_coefficients
    
    Previously each loop iteration did its accesses in the order:
       output[i], output[i+1], output[i],
       output[i+1], output[i+2], output[i+1]
    Now each iteration does:
       output[i], output[i], output[i+1]
       output[i+1], output[i+1], output[i+2]
    
    This turns out to matter on some architectures; for me it reduces
    the speed-curve25519-donna output by 3.7% (building with gcc 4.6).

commit 33274d2f8c3893a3c7a4cb26dbdbb276871fcb84
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 9 12:37:47 2011 -0400

    Improve speed and time-invariance of 32-bit freduce_coefficients
    
    Trick #1:
    
    Bizarrely, when told to generate 32-bit code for dividing int64_t by
    0x4000000l, gcc 4.6 (and probably earlier) generate code that
    contains an imul and a mul instruction, with a few shifts and adds.
    (This isn't as simple as just doing v>>26, since >> rounds negative
    numbers differently than /.  Fortunately, there's an easy
    bit-twiddling trick that I copied from clang.)
    
    The new code here is surrounded with an #ifdef TWOS_COMPLEMENT, so
    that it won't break weird chips.
    
    Trick #2:
    
    In the second iteration of the outer loop, only output[0] can be
    more than 32 bits wide: all the other output values will stay well
    under 32 bits.  Thus, we can manipulate them as s32 rather than as
    s64, saving a few more cycles.
    
    Trick #3:
    
    Also, this patch use the same trick as in freduce_degree to make
    the multiply-by-19 avoid 64-bit multiplication.
    
    Timing-invariance:
    
    The code now always runs through the outer loop twice or more.
    Previously, it would run through it sometimes once and sometimes
    twice.  (Three times is possible, but almost never happens.  We
    should still investigate whether we can cut down from two/three
    iterations to just two.)
    
    Together, these changes reduce the output of speed-curve25519-donna
    from 1415us to 1244us on my core2 desktop.

commit 234205ff1ecaf6b3c1dc76798a462c4293f31fdb
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 15:06:02 2011 -0400

    Update a couple of comments that missed the last commit

commit cf95fd4df2821d12137b09c28e29e0eb72fb2f50
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 14:11:06 2011 -0400

    Build 32-bit code in 32-bit mode and add comment.

commit c5ba8141422bcac53f1978227cd08fc76c290c30
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:49:46 2011 -0400

    Replace 64-bit mults by shifts and adds

commit 9666993f5bf49b07e92bd878015e94b57a967fe7
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:40:57 2011 -0400

    Switch to 32-bit mults

commit 0a2b79557a75e60906a67b77d6fd1d4da0b4429d
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 13:31:01 2011 -0400

    Rename felem to limb in order to match the NIST P-curve code

commit 78f3608ef90ff25f0701e52d635ac685ac5f52de
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 12:53:28 2011 -0400

    Simplify 32-bit freduce_coefficients.
    
    Speed up from 532us -> 466us.

commit 4302b45dcb584b022ed0c560f0ccb597ce401463
Author: Adam Langley <agl@chromium.org>
Date:   Tue Jun 7 11:10:28 2011 -0400

    Fix whitespace in 32-bit code (no code changes)

commit 6f00f5824a24d1edcdb90f552abe57c168d18548
Author: Adam Langley <agl@imperialviolet.org>
Date:   Sat Jan 29 15:02:51 2011 -0500

    Cheery-pick changes from floodyberry.
    
    The previous change is a merge from floodyberry. The important,
    algorithmic change in it is that the multiplication by 19 can be
    performed on one of the 64-bit inputs to the 64x64 multiplication. This
    is much better than multipling the 128-bit result by 19.
    
    The rest of the changes involve persuading the compiler to do a better
    job.
    
    In this change, I've taken some of floodyberry's changes only. This is
    because I favour a different balence between speed and readability.
    
    The only algorithmic change in this commit is new way of handing
    subtractions in the field. This is thanks to an idea from Emilia Kasper.
    
    If you want the fastest code possible, take the previous commit and
    replace the fdifference_backwards with the version from this commit.

commit 008aa9a69505362a73908fb42e592af4cf0fc3d8
Author: floodyberry <liquidsun@gmail.com>
Date:   Sat Nov 13 23:39:51 2010 -0600

    remove errant tabs

commit e77c1425712d7b3052beca7f00f36a98722e0541
Author: floodyberry <liquidsun@gmail.com>
Date:   Sat Nov 13 22:35:25 2010 -0600

    re-organized to avoid 128bit math at all costs. much faster now!
    
    mainloop & recip simplified and tightened
    
    fexpand & fcontract do bytewise reads&writes to avoid unaligned access
    issues (needed? unsure, but safer)

commit 6483797174a227d791ef367b9a7d6f75f206c796
Author: Brian Warner <warner@lothar.com>
Date:   Sat Feb 20 01:12:30 2010 +0800

    add a simple OOPish python binding, with tests and basic speed test
    
    curve25519 is simple enough to get a basic functional wrapper, but I wrote it
    OOP-style so it'll be harder to accidentally swap public and private keys

commit 80d716dba64b583386daa9be7ce9dce1b91607da
Author: Brian Warner <warner@lothar.com>
Date:   Fri Feb 19 06:01:11 2010 +0800

    ignore generated files

commit e48d4728c4eadd3e9232c4f732eb41f7938ccf45
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 15 17:33:37 2009 -0700

    c64: add additional step to carry chains
    
    Thanks to Alexander Sotirov to pushing me to check that the carry chains in
    donna-c64 were sufficient. I don't know if I realised something when I wrote it
    which I'm currently missing, or if I just screwed up, but I now believe that
    they're wrong:
    
    ----- start paste
    
    This Haskell code has been written to experiment with the carry chains in
    curve25519-donna-c64. It's a literate Haskell program, one can load it into
    GHCI and play along.
    
    > module Main where
    >
    > import Data.Bits (shiftR, (.&.))
    
    There are two constants that we'll need.
    
    Our five limbs are, nominally, 51 bits wide, so this is the maximum value of
    their initial values.
    
    > twoFiftyOneMinusOne = (2 ^ 51) - 1
    
    2^128 - 1 is the limit of the range of our temporary variables. If we exceed
    this at any point, our calculations will be incorrect.
    
    > two128MinusOne = (2 ^ 128) - 1
    
    Now we define a type which mimics our 128-bit unsigned type in C. It's a
    disjuction of an Integer and the distinguished value 'Overflow'. 'Overflow' is
    contagious: if we try to perform any operations where one or both of the
    operands is 'Overflow', then the result is also 'Overflow'.
    
    > data U128 = U128 Integer
    >           | Overflow
    >           deriving (Show, Eq)
    
    We make U128 an instance of Num so that we can perform arithmetic with it.
    
    > instance Num U128 where
    >   (U128 a) + (U128 b) = mayOverflow (a + b)
    >   _ + _ = Overflow
    >   (U128 a) * (U128 b) = mayOverflow (a * b)
    >   _ * _ = Overflow
    >   (U128 a) - (U128 b) = mayOverflow (a - b)
    >   _ - _ = Overflow
    >   negate _ = Overflow
    >   abs a@(U128 _) = a
    >   abs _ = Overflow
    >   signum (U128 _) = 1
    >   signum _ = 0
    >   fromInteger = mayOverflow
    
    > instance Ord U128 where
    >   compare (U128 a) (U128 b) = compare a b
    >   compare _ _ = EQ
    
    This function lifts an Integer to a U128. If the value is out of range, the
    result is 'Overflow'
    
    > mayOverflow :: Integer -> U128
    > mayOverflow x
    >   | x > two128MinusOne = Overflow
    >   | x < 0 = Overflow
    >   | otherwise = U128 x
    
    Our field elements consist of five limbs. In the C code, these limbs are
    actually uint64_t's, but we keep them as U128's here. We will convince ourselves
    that we don't hit any 64-bit overflows later.
    
    > data FieldElement = FieldElement { m0 :: U128, m1 :: U128, m2 :: U128,
    >                                    m3 :: U128, m4 :: U128 }
    >                                  deriving (Show, Eq)
    
    Now, two helper functions:
    
    This function takes only the bottom 51-bits of a value
    
    > clamp :: U128 -> U128
    > clamp (U128 a) = U128 $ a .&. 0x7ffffffffffff
    > clamp _ = Overflow
    
    This function drop the bottom 51-bits of a value
    
    > topBits :: U128 -> U128
    > topBits (U128 a) = U128 $ a `shiftR` 51
    > topBits _ = Overflow
    
    This function simulates the 'fsquare' function in donna-c64, including its carry
    chain. If the carry chain is sufficient, then iterating this function for any
    valid initial value should never overflow.
    
    > square :: FieldElement -> FieldElement
    > square e = result where
    >   t0 = m0 e * m0 e
    >   t1 = m0 e * m1 e +
    >        m1 e * m0 e
    >   t2 = m0 e * m2 e +
    >        m2 e * m0 e +
    >        m1 e * m1 e
    >   t3 = m0 e * m3 e +
    >        m3 e * m0 e +
    >        m1 e * m2 e +
    >        m2 e * m1 e
    >   t4 = m0 e * m4 e +
    >        m4 e * m0 e +
    >        m3 e * m1 e +
    >        m1 e * m3 e +
    >        m2 e * m2 e
    >   t5 = m4 e * m1 e +
    >        m1 e * m4 e +
    >        m2 e * m3 e +
    >        m3 e * m2 e
    >   t6 = m4 e * m2 e +
    >        m2 e * m4 e +
    >        m3 e * m3 e
    >   t7 = m3 e * m4 e +
    >        m4 e * m3 e
    >   t8 = m4 e * m4 e
    >
    >   t0' = t0 + t5 * 19
    >   t1' = t1 + t6 * 19
    >   t2' = t2 + t7 * 19
    >   t3' = t3 + t8 * 19
    >
    >   t1'' = t1' + topBits t0'
    >   t2'' = t2' + topBits t1''
    >   t3'' = t3' + topBits t2''
    >   t4' = t4 + topBits t3''
    >   t0'' = t0' + 19 * topBits t4'
    >   t1''' = clamp t1'' + topBits t0''
    
    At this point, we implement two carry chains. If 'currentChain' is true, then we
    implement the carry chain as currently written in donna-c64. Otherwise, we
    perform an extra step and carry t1 into t2.
    
    >   result = if currentChain
    >               then FieldElement (clamp t0'') t1''' (clamp t2'') (clamp t3'')
    >                                 (clamp t4')
    >               else FieldElement (clamp t0'') (clamp t1''') t2''' (clamp t3'')
    >                                 (clamp t4') where
    >                    t2''' = clamp t2'' + topBits t1'''
    
    This is the maximum initial element: an element where all limbs are 2^51 - 1.
    Inspection of the 'fexpand' function should be sufficient to convince oneself of
    this.
    
    > maxInitialElement :: FieldElement
    > maxInitialElement = FieldElement twoFiftyOneMinusOne twoFiftyOneMinusOne
    >                                  twoFiftyOneMinusOne twoFiftyOneMinusOne
    >                                  twoFiftyOneMinusOne
    
    This function takes two field elements and returns the worst case result: one
    where the maximum of each limb is chosen.
    
    > elementWiseMax :: FieldElement -> FieldElement -> FieldElement
    > elementWiseMax x y = FieldElement (f m0) (f m1) (f m2) (f m3) (f m4) where
    >   f :: (FieldElement -> U128) -> U128
    >   f accessor = max (accessor x) (accessor y)
    
    We now define a series of values generated by squaring the previous element and
    setting any limb that is less than the maximum to the maximum value.
    
    > maxSeries = iterate (elementWiseMax maxInitialElement . square)
    >                     maxInitialElement
    
    This value controls which carry chain is used in 'square', the current one or
    the one with the extra carry
    
    > currentChain = False
    
    By running this, we can see that the current carry chain is insufficient for
    this simulation:
    
    ghci> maxSeries !! 4
    FieldElement {m0 = Overflow, m1 = Overflow, m2 = Overflow, m3 = Overflow,
                  m4 = Overflow}
    
    The series overflows after only four iterations. However, if we use the
    alternative carry chain, the series is stable far beyound the requirements of
    the Montgomery ladder used in donna-c64:
    
    ghci> maxSeries !! 100000
    FieldElement {m0 = U128 2251799813685247, m1 = U128 2251799813685247,
                  m2 = U128 2251799813685247, m3 = U128 2251799813685247,
                  m4 = U128 2251799813685247}
    
    Additionally, these values are small enough not to overflow the 64-limb limbs.

commit e186866b8d31a4a74f5bdc3dfd19b1e73e876e96
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 14:12:25 2009 -0700

    Remove x86-64 version.
    
    With GCC 4.3, donna-c64 is now faster than donna-x86-64 on a Core2!
    Because of this, I'm removing the x86-64 version. Everyone should
    use c64 on 64-bit systems now.

commit fab6b1b0221b08474f1726875c24461520565593
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 13:52:34 2009 -0700

    donna-x86-64: port fcontract from c64
    
    This takes djb's fcontract from donna-c64 and uses it in x86-64.

commit f2f2a71966458ecce2bef9fdf3d9d90946161963
Author: Adam Langley <agl@chromium.org>
Date:   Sun Mar 8 12:58:38 2009 -0700

    Update fcontact in c64 with djb's version
    
    djb:
    I've expanded fcontract() in donna_c64 to do two extra rounds of carries
    and to reduce [0,2^255-1] to [0,2^255-20]. I haven't written down bounds
    on the intermediate variable sizes, and I haven't done artificial tests
    of the cases where the extra code would make a difference. I thought
    about modifying donna similarly, but donna_c64 is faster than donna on
    the most important target CPU (Core 2), so for the moment NaCl just uses
    donna_c64.

commit 21e17010f3d31374549f404b362d41dcc76f8de8
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 15:00:03 2008 -0700

    Add c64 to the `make test` target

commit a9fe4af0ede6b4bf94c461b39976584d018650d0
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 14:59:16 2008 -0700

    donna: final copy of the API change
    
    Masking and oring the secret is now the job of the curve25519 function. This is
    to match the API in NaCl.

commit 84d871d09a8d26962eeb88b3f7d59520ec539425
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 14:22:47 2008 -0700

    x86-64: make constant speed
    
    Thanks to djb for the review and suggestions

commit 06d0426d9a3c0b61d7438a64c329af122d66c2e3
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 12:17:25 2008 -0700

    Make c64 really side-channel free
    
    Thanks to djb for the review and suggested changes.

commit a07f33119ea0d09c93c1fb19937a9a25ef390047
Author: Adam Langley <agl@imperialviolet.org>
Date:   Mon Sep 15 11:09:38 2008 -0700

    API change: the masking and oring of bits is now performed in the curve25519
    function to match the API of NaCl.

commit f22a1dd27f9e8c027006f81e5d46fc6d3b062a75
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 15:53:57 2008 -0700

    Add the correct ELF visibility to fmonty (allows shared library building)

commit 0f02e43e1a151e57833e25d626d5a3cead3a9ef5
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:20:33 2008 -0700

    Last couple of fix ups.

commit a18738034a8ffa4cfa8722598ea8ba6e555b7327
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:19:04 2008 -0700

    Put c64 into public domain (thanks cdibona)

commit 6897a177ffd68faeeff39716da9a63c22d2a82ed
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:17:36 2008 -0700

    Implement fsquare for c64. Down to 240us.

commit b3f74a508b1e69ac3a292c604a7a6a56b727af31
Author: Adam Langley <agl@imperialviolet.org>
Date:   Thu Sep 4 13:09:45 2008 -0700

    Add new implementation: c64
    
    Side channel clean, pure C. Runs in 275us on a Core2 2.3GHz. Uses gcc's mode TI
    support to implement a 51-bit limb pattern for 64-bit platforms.

commit 1bafece6583e05c35209d4da9b7047863e8d81cc
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:17:10 2008 -0700

    Fix warning in test-curve25519

commit 0e09c6ca4010a0cb184a69fae8d85c7f6ee118c4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:14:45 2008 -0700

    Fix a couple of warnings and some typos in the Makefile

commit 16249ed62d4f3ed401131e4317f511e63c3126d4
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 14:12:19 2008 -0700

    x86-64: Add a test for constant timing

commit a3b51177f98945cd2e4aba4ad535eaa948213865
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:54:14 2008 -0700

    Add speed tests

commit 5dbc908bfbaec66cbdeb8948ce6fe34d4bdb772a
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:53:27 2008 -0700

    Use fsquare in a few more places

commit 5250732d0f37b6577a92ebc73a73c722e803d0f0
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:38:36 2008 -0700

    Make the test abort if anything fails

commit cecd37594eb3df9883ae9cfca7f29c1877683046
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:36:11 2008 -0700

    x86-64: make carry chains constant time

commit 889feb4e98e023cc60f146721f8b6bba2425396e
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 13:31:32 2008 -0700

    x86-64: Replace a C function using an if statement with asm code
    
    The if statement isn't constant time, so it has to go.

commit 8d0e542af7e035e0640a8a8489848e86498fd627
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:51:34 2008 -0700

    Switch copyright of x86-64 to public domain at the request of djb

commit fef0c248f4a34fe6d84f64e634dab6842a3aef3a
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:46:56 2008 -0700

    Add test suite

commit a0e25d631b48474aca391352a3899e66f7bd313d
Author: Adam Langley <agl@imperialviolet.org>
Date:   Wed Aug 20 10:43:57 2008 -0700

    Initial import
